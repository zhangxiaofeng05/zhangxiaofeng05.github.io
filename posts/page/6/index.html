<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | 风吹过的烟花</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - 风吹过的烟花">
<meta name="author" content="zhangxiaofeng05">
<link rel="canonical" href="https://zhangxiaofeng05.github.io/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zhangxiaofeng05.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zhangxiaofeng05.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zhangxiaofeng05.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zhangxiaofeng05.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zhangxiaofeng05.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://zhangxiaofeng05.github.io/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://zhangxiaofeng05.github.io/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://zhangxiaofeng05.github.io/posts/">
  <meta property="og:site_name" content="风吹过的烟花">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="hugo blog">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">
      <meta property="og:image" content="https://zhangxiaofeng05.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://zhangxiaofeng05.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="hugo blog">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zhangxiaofeng05.github.io/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zhangxiaofeng05.github.io/" accesskey="h" title="风吹过的烟花 (Alt + H)">风吹过的烟花</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zhangxiaofeng05.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://zhangxiaofeng05.github.io/posts/" title="Posts">
                    <span class="active">Posts</span>
                </a>
            </li>
            <li>
                <a href="https://zhangxiaofeng05.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://zhangxiaofeng05.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://zhangxiaofeng05.github.io/firefly/" title="Firefly">
                    <span>Firefly</span>
                </a>
            </li>
            <li>
                <a href="https://zhangxiaofeng05.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://zhangxiaofeng05.github.io/">Home</a></div>
  <h1>
    Posts
    <a href="/posts/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">java IO流
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>
从控制台输入输出 import java.util.Scanner; public class IoTest { public static void main(String args[]){ Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(n); String s = sc.next(); System.out.println(s); String line = sc.nextLine(); System.out.println(line);//从控制台输出 } } 字节流 FileOutputStream import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.OutputStream; public class IoTest { public static void main(String args[]){ File file = new File(&#34;aa.txt&#34;); try { //FileOutputStream(File,boolean) 是否把内容追加 OutputStream out = new FileOutputStream(file); String str = &#34;Hello World&#34;; byte[] b=str.getBytes(); out.write(b); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } FileInputStream import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.InputStream; public class IoTest { public static void main(String args[]){ try { File file = new File(&#34;E:&#34;&#43;File.separator&#43;&#34;tt.txt&#34;); InputStream is = new FileInputStream(file); // byte[] bytes = new byte[1024]; //也可以这样 byte[] bytes = new byte[(int) file.length()]; is.read(bytes); System.out.println(new String(bytes)); //关闭流 is.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } BufferedOutputStream import java.io.*; public class IoTest { public static void main(String args[]){ File file = new File(&#34;aa.txt&#34;); try { OutputStream out = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(out); byte[] bytes = &#34;土豆，土豆，呼叫土豆&#34;.getBytes(); bos.write(bytes); //刷新缓存 bos.flush(); bos.close(); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } BufferedInputStream import java.io.*; public class IoTest { public static void main(String args[]){ try { File file = new File(&#34;E:&#34;&#43;File.separator&#43;&#34;tt.txt&#34;); InputStream is = new FileInputStream(file); BufferedInputStream bis = new BufferedInputStream(is); byte[] bytes = new byte[(int) file.length()]; bis.read(bytes); System.out.println(new String(bytes)); bis.close(); is.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } 字符流 FileWriter import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.io.Writer; public class IoTest { public static void main(String args[]){ try { File file = new File(&#34;aa.txt&#34;); Writer writer = new FileWriter(file); writer.write(&#34;土豆。。。\n&#34;); writer.write(&#34;地瓜，对不起&#34;); writer.close(); } catch (IOException e) { e.printStackTrace(); } } } FileReader import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.Reader; public class IoTest { public static void main(String args[]){ try { File file = new File(&#34;aa.txt&#34;); Reader reader = new FileReader(file); char[] chars = new char[1024]; reader.read(chars); System.out.println(new String(chars)); reader.close(); } catch (IOException e) { e.printStackTrace(); } } } 转换流(字节流转字符流) OutputStreamWriter import java.io.*; public class IoTest { public static void main(String args[]){ File file = new File(&#34;aa.txt&#34;); try { OutputStream out = new FileOutputStream(file); OutputStreamWriter osw = new OutputStreamWriter(out); osw.write(&#34;这是字节流转成了字符流&#34;); String encoding = osw.getEncoding(); System.out.println(&#34;文件的编码：&#34;&#43;encoding); //文件的编码：UTF8 osw.close(); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } InputStreamReader import java.io.*; public class IoTest { public static void main(String args[]){ try { File file = new File(&#34;aa.txt&#34;); InputStream is = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(is,&#34;utf-8&#34;);//指定编码 char[] chars = new char[1024]; isr.read(chars); System.out.println(chars); System.out.println(&#34;编码：&#34;&#43;isr.getEncoding()); isr.close(); isr.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } 字符缓冲流(高效流) BufferedWriter import java.io.*; public class IoTest { public static void main(String args[]){ File file = new File(&#34;aa.txt&#34;); try { OutputStream out = new FileOutputStream(file); OutputStreamWriter osw = new OutputStreamWriter(out); BufferedWriter bw = new BufferedWriter(osw); bw.write(&#34;hello 这是字符缓冲流&#34;); bw.newLine(); bw.write(&#34;下一行&#34;); bw.close(); osw.close(); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } BufferedReader import java.io.*; public class IoTest { public static void main(String args[]){ try { File file = new File(&#34;aa.txt&#34;); InputStream is = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(is,&#34;utf-8&#34;); BufferedReader br = new BufferedReader(isr); String str; while ((str=br.readLine())!=null){ System.out.println(str); } br.close(); isr.close(); is.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } 字节流与字符流的区别 字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-07-25 15:38:45 +0800 +0800'>July 25, 2019</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to java IO流" href="https://zhangxiaofeng05.github.io/posts/java-io/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">java异常
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>
异常类型 检查性异常 最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略(Throw)。 错误 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 异常类Exception 构造方法 public Exception()
构建一个新的异常，以 null作为其详细信息。 public Exception(String message)
使用指定的详细消息构造新的异常。 public Exception(String message, Throwable cause)
构造一个新的异常与指定的详细信息和原因。 public Exception(Throwable cause)
构造一个新的异常与指定原因。 protected Exception(String message, Throwable cause,boolean enableSuppression,boolean writableStackTrace)
构造一个新的异常，其中包含指定的详细消息，启用或禁用抑制功能，启用或禁用可写栈跟踪。 常用方法 public String getMessage()
返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 public Throwable getCause()
返回一个Throwable 对象代表异常原因。 public String toString()
使用getMessage()的结果返回类的串级名字。 public void printStackTrace()
打印toString()结果和栈层次到System.err，即错误输出流。 public StackTraceElement [] getStackTrace()
返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 public Throwable fillInStackTrace()
用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 处理异常 try-catch public class MyException extends Exception{ public static void main(String[] args) { try { int i=1/0; }catch (ArithmeticException e){ e.printStackTrace(); } catch (Exception e){ e.printStackTrace(); System.out.println(&#34;这是总异常&#34;); }finally { System.out.println(&#34;无论有没有异常，都会执行。比如用于关闭数据库的连接&#34;); } } } throws public class MyException extends Exception{ public static void main(String[] args) { MyException myException = new MyException(); try { myException.show(); } catch (Exception e) { e.printStackTrace(); } } public void show() throws Exception{//抛出去，谁调用谁处理 int i=1/0; } } 注意事项 throws在方法名后边 catch 不能独立于 try 存在。 在 try/catch 后面添加 finally 块并非强制性要求的。 try 代码后不能既没 catch 块也没 finally 块。 try, catch, finally 块之间不能添加任何代码。
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-07-25 14:34:21 +0800 +0800'>July 25, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to java异常" href="https://zhangxiaofeng05.github.io/posts/java-exception/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java中Date、SimpleDateFormat、Calendar
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>jdk1.8 import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; /** * Java 语言的Date(日期)，Calendar(日历)，DateFormat(日期格式)组成了Java标准的一个基本但是非常重要的部分。 */ public class StringTest { public static void main(String[] args) throws ParseException { Date currentTime = new Date(); System.out.println(currentTime); //设置时间格式 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&#34;yyyy-MM-dd HH:mm:ss&#34;); System.out.println(simpleDateFormat.format(currentTime)); SimpleDateFormat year = new SimpleDateFormat(&#34;yyyy&#34;);//获取年----其它类似 System.out.println(year.format(currentTime)); Date date = simpleDateFormat.parse(&#34;2019-1-23 12:00:00&#34;);//把字符串转换成日期 System.out.println(simpleDateFormat.format(date)); //计算时间差currentTime-date相差多少天 Long days = (currentTime.getTime()-date.getTime())/(1000*60*60*24);//参数--毫秒 System.out.println(days); System.out.println(&#34;---------------------------利用Calendar获取时间值比较方便&#34;); // Calendar转化为Date Calendar cal=Calendar.getInstance(); Date date1=cal.getTime(); // Date转化为Calendar Calendar cal2=Calendar.getInstance(); cal2.setTime(date); //计算某个日期是那一年的第几天 int d = cal2.get(Calendar.DAY_OF_YEAR); System.out.println(d); //一年的第几周等。。 } } </p>
  </div>
  <footer class="entry-footer"><span title='2019-07-24 17:14:47 +0800 +0800'>July 24, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to Java中Date、SimpleDateFormat、Calendar" href="https://zhangxiaofeng05.github.io/posts/java-date-calender/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">String、StringBuffer、StringBuilder的区别
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>长度是否可变 String 是被 final 修饰的，他的长度是不可变的，就算调用 String 的concat 方法，那也是把字符串拼接起来并重新创建一个对象，把拼接后的 String 的值赋给新创建的对象 StringBuffer 和 StringBuilder修改本身 执行效率 三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String
应用场景 如果要操作少量的数据用 = String 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 多线程操作字符串缓冲区 下操作大量数据 = StringBuffer 线程安全 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问），StringBuffer是线程安全的。只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。
参考 https://www.cnblogs.com/AmyZheng/p/9415064.html
</p>
  </div>
  <footer class="entry-footer"><span title='2019-07-24 15:38:18 +0800 +0800'>July 24, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to String、StringBuffer、StringBuilder的区别" href="https://zhangxiaofeng05.github.io/posts/string-stringbuffer-stringbuilder/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java中的线程
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>进程和线程概念 进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。进程是线程的容器。
线程(thread)是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务。
同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。 一个进程可以有很多线程，每条线程并行执行不同的任务。
线程 在 Java程序中，有两种方法创建线程： 一继承Thread重写run方法 二是通过实现Runnable接口，实现run方法
线程总体分两类：用户线程和守候线程。 当所有用户线程执行完毕的时候，JVM自动关闭。但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的。
继承Thread public class ThreadOne extends Thread{ private String name; public ThreadOne() { } public ThreadOne(String name) { this.name = name; } @Override public void run() { for(int i=1;i&lt;=10;i&#43;&#43;){ System.out.println(name&#43;&#34;----&#34;&#43;i); } } } public class ThreadTest { public static void main(String[] args) { ThreadOne threadOne1 = new ThreadOne(&#34;地瓜&#34;); ThreadOne threadOne2 = new ThreadOne(&#34;土豆&#34;); threadOne1.start(); threadOne2.start(); } } 实现Runnable接口 public class ThreadTwo implements Runnable { private String name; public ThreadTwo() { } public ThreadTwo(String name) { this.name = name; } @Override public void run() { for(int i=1;i&lt;=10;i&#43;&#43;){ System.out.println(name&#43;&#34;-------&#34;&#43;i); } } } public class ThreadTest { public static void main(String[] args) { Thread t1 = new Thread(new ThreadTwo(&#34;地瓜&#34;)); Thread t2 = new Thread(new ThreadTwo(&#34;土豆&#34;)); t1.start(); t2.start(); } } 线程的转换 新建状态：线程对象已经创建 就绪状态：执行了start 运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。 阻塞：线程仍旧是活的，但是当前没有条件运行。 死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-07-24 11:40:48 +0800 +0800'>July 24, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to Java中的线程" href="https://zhangxiaofeng05.github.io/posts/java-thread/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring Boot打印日志
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文环境 jdk 1.8 maven 3.6.1 Spring Boot 2.1.6
SLF4J 为什么要介绍SLF4J？ SLF4J是一个接口，log4j和logback是它的实现。 SLF4J官网：https://www.slf4j.org
官网示例 引入jar包 slf4j-api-1.7.26.jar slf4j-simple-1.7.26.jar 编写测试类(Java Project) import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(&#34;Hello World&#34;); } } 有什么问题，去官网查看示例！
Spring Boot中使用日志(logback) 编写测试类 import org.junit.Test; import org.junit.runner.RunWith; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class LogbackTest { //记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void logTest() { //日志的级别 //从上到下---由低到高 //日志会在设置的级别和高级别生效，Spring Boot默认info logger.trace(&#34;这是trace日志...&#34;); logger.debug(&#34;这是debug日志...&#34;); //可以在logback-spring.xml或者在application.xml配置日志级别 logger.info(&#34;这是info日志...&#34;); logger.warn(&#34;这是warn日志...&#34;); logger.error(&#34;这是error日志...&#34;); } } 设置日志的格式 resources/logback-spring.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;configuration debug=&#34;false&#34; scan=&#34;true&#34; scanPeriod=&#34;60 seconds&#34;&gt; &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径 --&gt; &lt;!-- &lt;property name=&#34;LOG_PATH&#34; value=&#34;/data/log/process/springboot-demo&#34; /&gt; --&gt; &lt;springProperty name=&#34;LOG_PATH&#34; source=&#34;logging.path&#34; defaultValue=&#34;../logs&#34; /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&#34;STDOUT&#34; class=&#34;ch.qos.logback.core.ConsoleAppender&#34;&gt; &lt;encoder class=&#34;ch.qos.logback.classic.encoder.PatternLayoutEncoder&#34;&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;appender name=&#34;FILE&#34; class=&#34;ch.qos.logback.core.rolling.RollingFileAppender&#34;&gt; &lt;rollingPolicy class=&#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&#34;&gt; &lt;!--日志文件输出的文件名 --&gt; &lt;FileNamePattern&gt;${LOG_PATH}/log.log.%d{yyyy-MM-dd}&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数 --&gt; &lt;!-- &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; --&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&#34;ch.qos.logback.classic.encoder.PatternLayoutEncoder&#34;&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 日志输出级别 --&gt; &lt;root level=&#34;INFO&#34;&gt; &lt;appender-ref ref=&#34;FILE&#34; /&gt; &lt;appender-ref ref=&#34;STDOUT&#34; /&gt; &lt;/root&gt; &lt;/configuration&gt; 配置文件的加载顺序 application.properties或者application.yml文件作为Spring Boot的默认配置文件
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-07-20 14:32:00 +0800 +0800'>July 20, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to Spring Boot打印日志" href="https://zhangxiaofeng05.github.io/posts/spring-boot-logback/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring Boot发送邮件
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p> 本文环境 jdk 1.8 maven 3.6.1 Spring Boot 2.1.6
引入依赖 pom.xml
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 在application.properties中添加邮件配置(以QQ邮箱为例) spring.mail.host=smtp.qq.com spring.mail.port=587 spring.mail.username=xxx@qq.com spring.mail.password=授权码 spring.mail.properties.mail.smtp.auth=true spring.mail.properties.mail.smtp.starttls.enable=true spring.mail.properties.mail.smtp.starttls.required=true spring.mail.default-encoding=UTF-8 mail.fromMail.addr=xxx@qq.com #发送来源，和账户相同 QQ邮箱的服务器端口
接收邮件服务器：imap.qq.com，使用SSL，端口号993
发送邮件服务器：smtp.qq.com，使用SSL，端口号465或587
QQ邮箱帮助中心 编写Service接口 public interface MailService { public void sendSimpleMail(String to,String subject,String content); public void sendHtmlMail(String to, String subject, String content); public void sendAttachmentsMail(String to, String subject, String content, String filePath); } } 编写Service的实现类 import java.io.File; import javax.mail.MessagingException; import javax.mail.internet.MimeMessage; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.io.FileSystemResource; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSender; import org.springframework.mail.javamail.MimeMessageHelper; import org.springframework.stereotype.Component; @Component public class MailServiceImpl implements MailService{ private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private JavaMailSender mailSender; @Value(&#34;${mail.fromMail.addr}&#34;) private String from; @Override public void sendSimpleMail(String to, String subject, String content) { SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(content); try { mailSender.send(message); logger.info(&#34;简单邮件已经发送&#34;); } catch (Exception e) { logger.error(&#34;发送简单邮件时发生异常!&#34;,e); } } @Override public void sendHtmlMail(String to, String subject, String content) { MimeMessage message = mailSender.createMimeMessage(); try { //true表示需要创建一个multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); mailSender.send(message); logger.info(&#34;html邮件发送成功&#34;); } catch (MessagingException e) { logger.error(&#34;发送html邮件时发生异常！&#34;, e); } } @Override public void sendAttachmentsMail(String to, String subject, String content, String filePath) { MimeMessage message = mailSender.createMimeMessage(); try { MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName, file); mailSender.send(message); logger.info(&#34;带附件的邮件已经发送。&#34;); } catch (MessagingException e) { logger.error(&#34;发送带附件的邮件时发生异常！&#34;, e); } } } 编写测试类 import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import com.boot.service.MailService; @RunWith(SpringRunner.class) @SpringBootTest public class MailTest { @Autowired private MailService mailService; @Test public void testSimple() { mailService.sendSimpleMail(&#34;xxx@163.com&#34;, &#34;test simple mail&#34;, &#34;hello this is simple mail&#34;); } @Test public void testHtmlMail() throws Exception { String content=&#34;&lt;html&gt;\n&#34; &#43; &#34;&lt;body&gt;\n&#34; &#43; &#34; &lt;h3&gt;hello world ! 这是一封Html邮件!&lt;/h3&gt;\n&#34; &#43; &#34;&lt;/body&gt;\n&#34; &#43; &#34;&lt;/html&gt;&#34;; mailService.sendHtmlMail(&#34;xxx@163.com&#34;,&#34;test simple mail&#34;,content); } @Test public void sendAttachmentsMail() { String filePath=&#34;D:\\testMail.txt&#34;; mailService.sendAttachmentsMail(&#34;xxx@163.com&#34;, &#34;主题：带附件的邮件&#34;, &#34;有附件，请查收！&#34;, filePath); } } 至此，邮件发送成功!
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-07-19 14:59:20 +0800 +0800'>July 19, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to Spring Boot发送邮件" href="https://zhangxiaofeng05.github.io/posts/spring-boot-mail/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">request和Session
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p> 区别 request session 描述 一次请求(访问一个url) 一次对话(可以访问多个url) 作用 获取信息(表单,查询,cookie等信息) 记录变量(跟踪记录访问者动作) 作用端 浏览器 服务器 生命周期 提交以后即释放 关闭浏览器或者超出会话时间限制(maxInactiveIntervalInSeconds;The session timeout in seconds. By default, it is set to 1800 seconds (30 minutes).) 占用资源 比较少 相对较大 安全性 比较高 稍微低点 </p>
  </div>
  <footer class="entry-footer"><span title='2019-07-19 11:11:47 +0800 +0800'>July 19, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to request和Session" href="https://zhangxiaofeng05.github.io/posts/requestandsession/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Druid数据库连接池
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>阿里巴巴数据库事业部出品，为监控而生的数据库连接池。 托管于GitHub,项目地址 https://github.com/alibaba/druid Druid是一个JDBC组件库，包括数据库连接池、SQL Parser等组件。DruidDataSource是最好的数据库连接池。
Springboot使用 最新信息去GitHub
Maven &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt; &lt;/dependency&gt; Gradle compile &#39;com.alibaba:druid-spring-boot-starter:1.1.17&#39; 配置 Github上有说明，下面是一下常用配置 application.properties
#mysql spring.datasource.platform=mysql spring.datasource.url=jdbc:mysql://localhost:3306/database?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8 spring.datasource.username=root spring.datasource.password=154704 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #druid spring.datasource.type=com.alibaba.druid.pool.DruidDataSource # Advanced configuration... spring.datasource.max-active=500 spring.datasource.min-idle=2 spring.datasource.initial-size=6 开启监测 DruidConfiguration 监测地址：http://localhost:8080/druid/index.html
import javax.sql.DataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.alibaba.druid.pool.DruidDataSource; import com.alibaba.druid.support.http.StatViewServlet; @Configuration public class DruidConfiguration { @ConfigurationProperties(&#34;spring.datasource&#34;) @Bean public DataSource druidDataSource() { return new DruidDataSource(); } @Bean public ServletRegistrationBean&lt;StatViewServlet&gt; druidStatViewServlet() { ServletRegistrationBean&lt;StatViewServlet&gt; registrationBean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &#34;/druid/*&#34;); registrationBean.addInitParameter(&#34;allow&#34;, &#34;127.0.0.1&#34;);// IP白名单 (没有配置或者为空，则允许所有访问) registrationBean.addInitParameter(&#34;deny&#34;, &#34;&#34;);// IP黑名单 (存在共同时，deny优先于allow) registrationBean.addInitParameter(&#34;loginUsername&#34;, &#34;root&#34;); registrationBean.addInitParameter(&#34;loginPassword&#34;, &#34;123456&#34;); registrationBean.addInitParameter(&#34;resetEnable&#34;, &#34;false&#34;); return registrationBean; } } 测试类 import java.sql.Connection; import javax.sql.DataSource; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class SpringbootApplicationTests { @Autowired DataSource dataSource; @Test public void contextLoads() { } @Test public void test1() throws Exception { System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection.getClass()); connection.close(); } } </p>
  </div>
  <footer class="entry-footer"><span title='2019-07-18 15:33:15 +0800 +0800'>July 18, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to Druid数据库连接池" href="https://zhangxiaofeng05.github.io/posts/druid-database-connection-pool/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Object类
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>特点 是Java中唯一一个没有父类的类 java中所有的类不是object类的直接子类，就是其间接子类 定义在object类中的所有方法，在任何类中都可以直接调用，而不需要声明object类的对象。 是java中所有类的超类（基类 ，父类） object类中只有无参构造 方法 常用方法 public boolean equals（object obj） public boolean equals(Object obj) { return (this == obj); } 指示其他某个对象是否与此对象“相等”。 (ps:==判断是否引用地址相同) 2. public String tostring（)
返回对象的字符串表示形式。 3. public int hashCode()
返回此对象的一个哈希码值。
不常用方法 protected Object clone()
创建并返回此对象的一个副本。 protected void finalize()
当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 finalize 方法，以配置系统资源或执行其他清除。 public final Class&lt;?&gt; getClass()
返回此 Object 的运行时类。 public final void notify()
唤醒在此对象监视器上等待的单个线程。 public final void notifyAll()
唤醒在此对象监视器上等待的所有线程。 public final void wait()
在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。 public final void wait(long timeout)
在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。 public final void wait(long timeout,int nanos)
在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。 </p>
  </div>
  <footer class="entry-footer"><span title='2019-07-18 13:42:14 +0800 +0800'>July 18, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to Object类" href="https://zhangxiaofeng05.github.io/posts/object/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://zhangxiaofeng05.github.io/posts/page/5/">
      «&nbsp;Prev&nbsp;5/7
    </a>
    <a class="next" href="https://zhangxiaofeng05.github.io/posts/page/7/">Next&nbsp;7/7&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://zhangxiaofeng05.github.io/">风吹过的烟花</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
