<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | 风吹过的烟花</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - 风吹过的烟花">
<meta name="author" content="zhangxiaofeng05">
<link rel="canonical" href="https://zhangxiaofeng05.github.io/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zhangxiaofeng05.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zhangxiaofeng05.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zhangxiaofeng05.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zhangxiaofeng05.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zhangxiaofeng05.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://zhangxiaofeng05.github.io/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://zhangxiaofeng05.github.io/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://zhangxiaofeng05.github.io/posts/">
  <meta property="og:site_name" content="风吹过的烟花">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="hugo blog">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">
      <meta property="og:image" content="https://zhangxiaofeng05.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://zhangxiaofeng05.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="hugo blog">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zhangxiaofeng05.github.io/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zhangxiaofeng05.github.io/" accesskey="h" title="风吹过的烟花 (Alt + H)">风吹过的烟花</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zhangxiaofeng05.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://zhangxiaofeng05.github.io/posts/" title="Posts">
                    <span class="active">Posts</span>
                </a>
            </li>
            <li>
                <a href="https://zhangxiaofeng05.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://zhangxiaofeng05.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://zhangxiaofeng05.github.io/firefly/" title="Firefly">
                    <span>Firefly</span>
                </a>
            </li>
            <li>
                <a href="https://zhangxiaofeng05.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://zhangxiaofeng05.github.io/">Home</a></div>
  <h1>
    Posts
    <a href="/posts/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">行为型模式-中介者模式
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>维基百科 中介者模式 在软件工程领域，中介者模式定义了一个中介者对象，该对象封装了系统中对象间的交互方式。 由于它可以在运行时改变程序的行为，这种模式是一种行为型模式 。
通常程序由大量的类组成，这些类中包含程序的逻辑和运算。 然而，当开发者将更多的类加入到程序中之后，类间交互关系可能变得更为复杂，这会使得代码变得更加难以阅读和维护，尤其是在重构的时候。 此外，程序将会变得难以修改，因为对其所做的任何修改都有可能影响到其它几个类中的代码。
在中介者模式中，对象间的通信过程被封装在一个中介者（调解人）对象之中。 对象之间不再直接交互，而是通过调解人进行交互。 这么做可以减少可交互对象间的依赖，从而降低耦合。
概述 中介者模式是23个周知模式（ 即GoF设计模式）中的一个，GoF设计模式旨在提供重复出现的设计问题的解决方案，以编写灵活和可复用的面向对象软件。也就是说，使对象更加易于实现、修改、测试和复用。
中介者设计模式可以解决什么问题？
避免一组相互交互的对象之间出现紧耦合。 能够独立地改变一组对象之间的交互关系而不影响其他对象。 使用直接逐个访问并更新彼此的方式进行对象间的交互灵活性低，因为这种方式使对象彼此间紧密耦合，导致不可能单独修改类间交互关系本身，而不影响关系中进行交互的类。并且这种方式会令对象变得无法复用，并且难以测试。
由于紧耦合的对象过多了解其他对象的内部细节，这种对象难以实现、修改、测试以及复用。
中介者模式如何解决上述问题？
定义一个独立的中介者(调解员)的对象，封装一组对象之间的交互关系。 对象将自己的交互委托给中介者执行，避免直接与其他对象进行交互。 对象利用中介者对象与其他对象进行间接交互，中介者对象负责控制和协调交互关系，这么做可使得对象间松耦合。这些对象只访问中介者，不了解其他对象的细节。
定义 中介者模式是为了“定义一个封装了对象间交互关系的对象”。这种方式避免了显式调用其他类，促进了类间的松耦合，并且使得类间交互关系本身可以单独修改。客户类可以使用中介者向其他客户类发送信息，并且通过中介者引发的事件收到信息。
Java 在以下示例中，一个中介者对象控制了三个互相交互的按钮的状态，为此它有设置状态的三个方法：book(), view() 和 search()。 当相应的按钮被激活时，对应的方法通过execute()方法被调用。
于是这里在交互中每个交互的参与者（本例中即按钮）将自己的行为提交给中介者并且由中介者将这些行为转给对应的参与者。
import java.awt.Font; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; //Colleague interface interface Command { void execute(); } //Abstract Mediator interface Mediator { void book(); void view(); void search(); void registerView(BtnView v); void registerSearch(BtnSearch s); void registerBook(BtnBook b); void registerDisplay(LblDisplay d); } //Concrete mediator class ParticipantMediator implements Mediator { BtnView btnView; BtnSearch btnSearch; BtnBook btnBook; LblDisplay show; //.... public void registerView(BtnView v) { btnView = v; } public void registerSearch(BtnSearch s) { btnSearch = s; } public void registerBook(BtnBook b) { btnBook = b; } public void registerDisplay(LblDisplay d) { show = d; } public void book() { btnBook.setEnabled(false); btnView.setEnabled(true); btnSearch.setEnabled(true); show.setText(&#34;booking...&#34;); } public void view() { btnView.setEnabled(false); btnSearch.setEnabled(true); btnBook.setEnabled(true); show.setText(&#34;viewing...&#34;); } public void search() { btnSearch.setEnabled(false); btnView.setEnabled(true); btnBook.setEnabled(true); show.setText(&#34;searching...&#34;); } } //A concrete colleague class BtnView extends JButton implements Command { Mediator med; BtnView(ActionListener al, Mediator m) { super(&#34;View&#34;); addActionListener(al); med = m; med.registerView(this); } public void execute() { med.view(); } } //A concrete colleague class BtnSearch extends JButton implements Command { Mediator med; BtnSearch(ActionListener al, Mediator m) { super(&#34;Search&#34;); addActionListener(al); med = m; med.registerSearch(this); } public void execute() { med.search(); } } //A concrete colleague class BtnBook extends JButton implements Command { Mediator med; BtnBook(ActionListener al, Mediator m) { super(&#34;Book&#34;); addActionListener(al); med = m; med.registerBook(this); } public void execute() { med.book(); } } class LblDisplay extends JLabel { Mediator med; LblDisplay(Mediator m) { super(&#34;Just start...&#34;); med = m; med.registerDisplay(this); setFont(new Font(&#34;Arial&#34;, Font.BOLD, 24)); } } class MediatorDemo extends JFrame implements ActionListener { Mediator med = new ParticipantMediator(); MediatorDemo() { JPanel p = new JPanel(); p.add(new BtnView(this, med)); p.add(new BtnBook(this, med)); p.add(new BtnSearch(this, med)); getContentPane().add(new LblDisplay(med), &#34;North&#34;); getContentPane().add(p, &#34;South&#34;); setSize(400, 200); setVisible(true); } public void actionPerformed(ActionEvent ae) { Command comd = (Command) ae.getSource(); comd.execute(); } public static void main(String[] args) { new MediatorDemo(); } } 例子 Colleagueclass
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-08-26 23:28:40 +0800 +0800'>August 26, 2019</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to 行为型模式-中介者模式" href="https://zhangxiaofeng05.github.io/posts/mediator-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">行为型模式-迭代器模式
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>维基百科 迭代器模式 在 面向对象编程里，迭代器模式是一种设计模式，是一种最简单也最常见的设计模式。它可以让用户透过特定的接口巡访容器中的每一个元素而不用了解底层的实现。
此外，也可以实现特定目的版本的迭代器。
接口 《设计模式》建议合理的接口该要有：
public interface Iterator { public Object First(); public Object Next(); public boolean isDone(); public Object CurrentItem(); } Java interface Iterator{ Object First(); Object Next(); boolean IsDone(); Object CurrentItem(); } abstract class Aggregate{ abstract Iterator CreateIterator(); } class ConcreteIterator implements Iterator{ private List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); private int curr=0; public ConcreteIterator(List&lt;Object&gt; list){ this.list = list; } public Object First(){ return list.get(0); } public Object Next(){ Object ret = null; curr&#43;&#43;; if(curr &lt; list.size()){ ret = list.get(curr); } return ret; } public boolean IsDone(){ return curr&gt;=list.size()?true:false; } public Object CurrentItem(){ return list.get(curr); } } class ConcreteAggregate extends Aggregate{ private List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); public ConcreteAggregate(List&lt;Object&gt; list){ this.list = list; } public Iterator CreateIterator(){ return new ConcreteIterator(list); } } class client{ public static void main(String[] args){ List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); list.add(&#34;miner&#34;); list.add(&#34;any&#34;); Aggregate agg = new ConcreteAggregate(list); Iterator iterator = agg.CreateIterator(); iterator.First(); while(!iterator.IsDone()){ System.out.println(iterator.CurrentItem()); iterator.Next(); } } } 例子 Aggregate 聚合定义创建相应迭代器对象的接口。
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-08-26 15:47:11 +0800 +0800'>August 26, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to 行为型模式-迭代器模式" href="https://zhangxiaofeng05.github.io/posts/iterator-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">行为型模式-命令模式
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>维基百科 命令模式 在面向对象编程的范畴中，命令模式（英语：Command pattern）是一种设计模式，它尝试以对象来代表实际行动。命令对象可以把行动(action) 及其参数封装起来，于是这些行动可以被：
重复多次 取消（如果该对象有实现的话） 取消后又再重做 这些都是现代大型应用程序所必须的功能，即“撤销”及“重复”。除此之外，可以用命令模式来实现的功能例子还有：
交易行为 进度列 向导 用户界面按钮及功能表项目 线程 pool 宏收录 Java import java.util.List; import java.util.ArrayList; /* The Command interface */ public interface Command { void execute(); } /* The Invoker class */ public class Switch { private List&lt;Command&gt; history = new ArrayList&lt;Command&gt;(); public Switch() { } public void storeAndExecute(Command cmd) { this.history.add(cmd); // optional cmd.execute(); } } /* The Receiver class */ public class Light { public Light() { } public void turnOn() { System.out.println(&#34;The light is on&#34;); } public void turnOff() { System.out.println(&#34;The light is off&#34;); } } /* The Command for turning on the light - ConcreteCommand #1 */ public class FlipUpCommand implements Command { private Light theLight; public FlipUpCommand(Light light) { this.theLight = light; } public void execute(){ theLight.turnOn(); } } /* The Command for turning off the light - ConcreteCommand #2 */ public class FlipDownCommand implements Command { private Light theLight; public FlipDownCommand(Light light) { this.theLight = light; } public void execute() { theLight.turnOff(); } } /* The test class or client */ public class PressSwitch { public static void main(String[] args){ Light lamp = new Light(); Command switchUp = new FlipUpCommand(lamp); Command switchDown = new FlipDownCommand(lamp); Switch mySwitch = new Switch(); try { if (&#34;ON&#34;.equalsIgnoreCase(args[0])) { mySwitch.storeAndExecute(switchUp); } else if (&#34;OFF&#34;.equalsIgnoreCase(args[0])) { mySwitch.storeAndExecute(switchDown); } else { System.out.println(&#34;Argument \&#34;ON\&#34; or \&#34;OFF\&#34; is required.&#34;); } } catch (Exception e) { System.out.println(&#34;Arguments required.&#34;); } } } 例子 Receiver 知道如何实现与执行一个请求相关的操作。任何类都可能作为一个接收者。
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-08-26 11:33:26 +0800 +0800'>August 26, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to 行为型模式-命令模式" href="https://zhangxiaofeng05.github.io/posts/command-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">行为型模式-责任链模式
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>维基百科 责任链模式 责任链模式在面向对象程式设计里是一种软件设计模式，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。
Java 以下的日志类(logging)例子演示了该模式。 每一个logging handler首先决定是否需要在该层做处理，然后将控制传递到下一个logging handler。程序的输出是:
Writing to debug output: Entering function y. Writing to debug output: Step1 completed. Sending via e-mail: Step1 completed. Writing to debug output: An error has occurred. Sending via e-mail: An error has occurred. Writing to stderr: An error has occurred. 注意：该例子不是日志类的推荐实现方式。
同时，需要注意的是，通常在责任链模式的实现中，如果在某一层已经处理了这个logger，那么这个logger就不会传递下去。在我们这个例子中，消息会一直传递到最底层不管它是否已经被处理。
abstract class Logger { public static int ERR = 3; public static int NOTICE = 5; public static int DEBUG = 7; protected int mask; // The next element in the chain of responsibility protected Logger next; public Logger setNext( Logger l) { next = l; return this; } public final void message( String msg, int priority ) { if ( priority &lt;= mask ) { writeMessage( msg ); if ( next != null ) { next.message( msg, priority ); } } } protected abstract void writeMessage( String msg ); } class StdoutLogger extends Logger { public StdoutLogger( int mask ) { this.mask = mask; } protected void writeMessage( String msg ) { System.out.println( &#34;Writting to stdout: &#34; &#43; msg ); } } class EmailLogger extends Logger { public EmailLogger( int mask ) { this.mask = mask; } protected void writeMessage( String msg ) { System.out.println( &#34;Sending via email: &#34; &#43; msg ); } } class StderrLogger extends Logger { public StderrLogger( int mask ) { this.mask = mask; } protected void writeMessage( String msg ) { System.out.println( &#34;Sending to stderr: &#34; &#43; msg ); } } public class ChainOfResponsibilityExample { public static void main( String[] args ) { // Build the chain of responsibility Logger l = new StdoutLogger( Logger.DEBUG).setNext( new EmailLogger( Logger.NOTICE ).setNext( new StderrLogger( Logger.ERR ) ) ); // Handled by StdoutLogger l.message( &#34;Entering function y.&#34;, Logger.DEBUG ); // Handled by StdoutLogger and EmailLogger l.message( &#34;Step1 completed.&#34;, Logger.NOTICE ); // Handled by all three loggers l.message( &#34;An error has occurred.&#34;, Logger.ERR ); } } 例子 public interface Request { } public class DimissionRequest implements Request { } public class AddMoneyRequest implements Request { } public class LeaveRequest implements Request { } Handler
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-08-26 08:54:49 +0800 +0800'>August 26, 2019</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to 行为型模式-责任链模式" href="https://zhangxiaofeng05.github.io/posts/responsibility-chain-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型模式-代理模式
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>维基百科 代理模式 代理模式（英语：Proxy Pattern）是程序设计中的一种设计模式。
所谓的代理者是指一个类别可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、存储器中的大对象、文件或其它昂贵或无法复制的资源。
著名的代理模式例子为引用计数（英语：reference counting）指针对象。
当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少存储器用量。典型作法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。
Java 以下Java示例解释&#34;虚拟代理&#34;模式。ProxyImage 类别用来访问远程方法。
import java.util.*; interface Image { public void displayImage(); } //on System A class RealImage implements Image { private String filename; public RealImage(String filename) { this.filename = filename; loadImageFromDisk(); } private void loadImageFromDisk() { System.out.println(&#34;Loading &#34; &#43; filename); } public void displayImage() { System.out.println(&#34;Displaying &#34; &#43; filename); } } //on System B class ProxyImage implements Image { private String filename; private Image image; public ProxyImage(String filename) { this.filename = filename; } public void displayImage() { if(image == null) image = new RealImage(filename); image.displayImage(); } } class ProxyExample { public static void main(String[] args) { Image image1 = new ProxyImage(&#34;HiRes_10MB_Photo1&#34;); Image image2 = new ProxyImage(&#34;HiRes_10MB_Photo2&#34;); image1.displayImage(); // loading necessary image2.displayImage(); // loading necessary } } 程序的输出为：
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-08-25 22:46:31 +0800 +0800'>August 25, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to 结构型模式-代理模式" href="https://zhangxiaofeng05.github.io/posts/proxy-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型模式-享元模式
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>维基百科 享元模式 享元模式（英语：Flyweight Pattern）是一种软件设计模式。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。
典型的享元模式的例子为文书处理器中以图形结构来表示字符。一个做法是，每个字形有其字型外观, 字模 metrics, 和其它格式资讯，但这会使每个字符就耗用上千字节。取而代之的是，每个字符参照到一个共享字形物件，此物件会被其它有共同特质的字符所分享；只有每个字符（文件中或页面中）的位置才需要另外储存。
Java 以下程式用来解释上述的文字。这个例子用来解释享元模式利用只加载执行任务时所必需的最少资料，因而减少内存使用量。
public enum FontEffect { BOLD, ITALIC, SUPERSCRIPT, SUBSCRIPT, STRIKETHROUGH } public final class FontData { /** * A weak hash map will drop unused references to FontData. * Values have to be wrapped in WeakReferences, * because value objects in weak hash map are held by strong references. */ private static final WeakHashMap&lt;FontData, WeakReference&lt;FontData&gt;&gt; FLY_WEIGHT_DATA = new WeakHashMap&lt;FontData, WeakReference&lt;FontData&gt;&gt;(); private final int pointSize; private final String fontFace; private final Color color; private final Set&lt;FontEffect&gt; effects; private FontData(int pointSize, String fontFace, Color color, EnumSet&lt;FontEffect&gt; effects) { this.pointSize = pointSize; this.fontFace = fontFace; this.color = color; this.effects = Collections.unmodifiableSet(effects); } public static FontData create(int pointSize, String fontFace, Color color, FontEffect... effects) { EnumSet&lt;FontEffect&gt; effectsSet = EnumSet.noneOf(FontEffect.class); for (FontEffect fontEffect : effects) { effectsSet.add(fontEffect); } // We are unconcerned with object creation cost, we are reducing overall memory consumption FontData data = new FontData(pointSize, fontFace, color, effectsSet); // Retrieve previously created instance with the given values if it (still) exists WeakReference&lt;FontData&gt; ref = FLY_WEIGHT_DATA.get(data); FontData result = (ref != null) ? ref.get() : null; // Store new font data instance if no matching instance exists if (result == null) { FLY_WEIGHT_DATA.put(data, new WeakReference&lt;FontData&gt; (data)); result = data; } // return the single immutable copy with the given values return result; } @Override public boolean equals(Object obj) { if (obj instanceof FontData) { if (obj == this) { return true; } FontData other = (FontData) obj; return other.pointSize == pointSize &amp;&amp; other.fontFace.equals(fontFace) &amp;&amp; other.color.equals(color) &amp;&amp; other.effects.equals(effects); } return false; } @Override public int hashCode() { return (pointSize * 37 &#43; effects.hashCode() * 13) * fontFace.hashCode(); } // Getters for the font data, but no setters. FontData is immutable. } 例子 Flyweight
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-08-25 10:51:19 +0800 +0800'>August 25, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to 结构型模式-享元模式" href="https://zhangxiaofeng05.github.io/posts/flyweight-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型模式-外观模式
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>维基百科 外观模式 外观模式（Facade pattern），是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。
Java 这是一个抽象的示例。一个客户“you”通过外观接口“computer”获取计算机内部复杂的系统信息。
/* Complex parts */ class CPU { public void freeze() { ... } public void jump(long position) { ... } public void execute() { ... } } class Memory { public void load(long position, byte[] data) { ... } } class HardDrive { public byte[] read(long lba, int size) { ... } } /* Façade */ class Computer { public void startComputer() { cpu.freeze(); memory.load(BOOT_ADDRESS, hardDrive.read(BOOT_SECTOR, SECTOR_SIZE)); cpu.jump(BOOT_ADDRESS); cpu.execute(); } } /* Client */ class You { public static void main(String[] args) { Computer facade = new Computer(); facade.startComputer(); } } 例子 抽象类
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-08-25 10:20:54 +0800 +0800'>August 25, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to 结构型模式-外观模式" href="https://zhangxiaofeng05.github.io/posts/facade-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型模式-装饰模式
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>维基百科 修饰模式 修饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。
介绍 通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。
修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。
当有几个相互独立的功能需要扩充时，这个区别就变得很重要。在有些面向对象的编程语言中，类不能在运行时被创建，通常在设计的时候也不能预测到有哪几种功能组合。这就意味着要为每一种组合创建一个新类。相反，修饰模式是面向运行时候的对象实例的,这样就可以在运行时根据需要进行组合。一个修饰模式的示例是JAVA里的Java I/O Streams的实现。
动机 例如，一个窗口系统中的窗口，允许这个窗口内容滚动，我们希望给它添加水平或垂直滚动条。假设窗口通过“Window”类实例来表示，并且假设它没有添加滚动条功能。我们可以创建一个子类“ScrollingWindow”来提供，或者我们可以创建一个ScrollingWindowDecorator来为已存在的Window对象添加这个功能。在这点上，只要是解决方案就可以了。 现在我们假设希望选择给我们的窗口添加边框，同样，我们的原始Window类不支持。ScrollingWindow子类现在会造成一个问题，因为它会有效的创建一种新的窗口。如果我们想要给所有窗口添加边框，我们必须创建WindowWithBorder和ScrollingWindowWithBorder子类。显然，这个问题由于被添加类而变得更糟了。对于修饰模式，我们简单的创建一个新类BorderedWindowDecorator，在运行时，我们能够使用ScrollingWindowDecorator或BorderedWindowDecorator或两者结合来修饰已存在的窗口。 一个修饰能够被应用的另一个好例子是当有需要根据某套规则或者几个平行的规则集（不同的用户凭据等）限制访问对象的属性或方法时。
一个对象的属性或方法按照某组规则或几个并行规则(不同用户证书等)需要限制访问时，在这种情况下，不是在原始对象中实现访问控制而是在他的使用中不变或不知道任何限制，并且他被包装在一个访问控制修饰对象中，这个对象能够对允许的原始对象的接口子集服务。
应用 Java IO 流为典型的装饰模式。
Java 这个JAVA示例使用window/scrolling情境。
// The Window interface class public interface Window { public void draw(); // Draws the Window public String getDescription(); // Returns a description of the Window } // implementation of a simple Window without any scrollbars public class SimpleWindow implements Window { public void draw() { // Draw window } public String getDescription() { return &#34;simple window&#34;; } } 以下类包含所有Window类的decorator，以及修饰类本身。
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-08-25 09:31:07 +0800 +0800'>August 25, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to 结构型模式-装饰模式" href="https://zhangxiaofeng05.github.io/posts/decorator-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型模式-桥接模式
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>维基百科 桥接模式 桥接模式是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。
Java /** &#34;Implementor&#34; */ interface DrawingAPI { public void drawCircle(double x, double y, double radius); } /** &#34;ConcreteImplementor&#34; 1/2 */ class DrawingAPI1 implements DrawingAPI { public void drawCircle(double x, double y, double radius) { System.out.printf(&#34;API1.circle at %f:%f radius %f\n&#34;, x, y, radius); } } /** &#34;ConcreteImplementor&#34; 2/2 */ class DrawingAPI2 implements DrawingAPI { public void drawCircle(double x, double y, double radius) { System.out.printf(&#34;API2.circle at %f:%f radius %f\n&#34;, x, y, radius); } } /** &#34;Abstraction&#34; */ interface Shape { public void draw(); // low-level public void resizeByPercentage(double pct); // high-level } /** &#34;Refined Abstraction&#34; */ class CircleShape implements Shape { private double x, y, radius; private DrawingAPI drawingAPI; public CircleShape(double x, double y, double radius, DrawingAPI drawingAPI) { this.x = x; this.y = y; this.radius = radius; this.drawingAPI = drawingAPI; } // low-level i.e. Implementation specific public void draw() { drawingAPI.drawCircle(x, y, radius); } // high-level i.e. Abstraction specific public void resizeByPercentage(double pct) { radius *= pct; } } /** &#34;Client&#34; */ class BridgePattern { public static void main(String[] args) { Shape[] shapes = new Shape[2]; shapes[0] = new CircleShape(1, 2, 3, new DrawingAPI1()); shapes[1] = new CircleShape(5, 7, 11, new DrawingAPI2()); for (Shape shape : shapes) { shape.resizeByPercentage(2.5); shape.draw(); } } } 运行结果：
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-08-24 21:46:01 +0800 +0800'>August 24, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to 结构型模式-桥接模式" href="https://zhangxiaofeng05.github.io/posts/bridge-pattern/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">结构型模式-适配器模式
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h2>
  </header>
  <div class="entry-content">
    <p>维基百科 适配器模式 在设计模式中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。
结构 有两种类型的适配器模式：
对象适配器模式 在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。
类适配器模式 这种适配器模式下，适配器继承自已实现的类（一般多重继承）。
例子 Target 定义Client使用的与特定领域相关的接口。
public interface Target { void adapteeMethod(); void adapterMethod(); } Adaptee 定义一个已经存在的接口，这个接口需要适配。
public class Adaptee { public void adapteeMethod(){ System.out.println(&#34;Adaptee method&#34;); } } Adapter 对Adaptee的接口与Target接口进行适配
public class Adapter implements Target{ private Adaptee adaptee; public Adapter(Adaptee adaptee){ this.adaptee=adaptee; } @Override public void adapteeMethod() { adaptee.adapteeMethod(); } @Override public void adapterMethod() { System.out.println(&#34;Adapter method&#34;); } } Client 与符合Target接口的对象协同。
public class Test { public static void main(String[] args) { Target target = new Adapter(new Adaptee()); target.adapteeMethod(); target.adapterMethod(); } } 运行结果：
...</p>
  </div>
  <footer class="entry-footer"><span title='2019-08-24 21:12:02 +0800 +0800'>August 24, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;zhangxiaofeng05</footer>
  <a class="entry-link" aria-label="post link to 结构型模式-适配器模式" href="https://zhangxiaofeng05.github.io/posts/adapter-pattern/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://zhangxiaofeng05.github.io/posts/page/3/">
      «&nbsp;Prev&nbsp;3/7
    </a>
    <a class="next" href="https://zhangxiaofeng05.github.io/posts/page/5/">Next&nbsp;5/7&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://zhangxiaofeng05.github.io/">风吹过的烟花</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
