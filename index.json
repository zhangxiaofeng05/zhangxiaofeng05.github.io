[{"categories":["linux"],"content":"首先在阿里云购买域名，申请域名证书，可以免费申请一年 ","date":"2021-01-10","objectID":"/aliyun_nginx_https/:0:1","tags":["linux"],"title":"Aliyun用nginx配置https","uri":"/aliyun_nginx_https/"},{"categories":["linux"],"content":"nginx配置https过程 https://yq.aliyun.com/articles/672835 ","date":"2021-01-10","objectID":"/aliyun_nginx_https/:0:2","tags":["linux"],"title":"Aliyun用nginx配置https","uri":"/aliyun_nginx_https/"},{"categories":["linux"],"content":"示例 server { listen 444 ssl; server_name zhangxiaofeng.top localhost; # ssl证书地址 ssl_certificate /etc/nginx/cert/4879361_zhangxiaofeng.top.pem; # pem文件的路径 ssl_certificate_key /etc/nginx/cert/4879361_zhangxiaofeng.top.key; # key文件的路径 # ssl验证相关配置 ssl_session_timeout 5m; #缓存有效期 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #加密算法 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #安全链接可选的加密协议 ssl_prefer_server_ciphers on; #使用服务器端的首选算法 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } 访问： https://zhangxiaofeng.top:444 ","date":"2021-01-10","objectID":"/aliyun_nginx_https/:0:3","tags":["linux"],"title":"Aliyun用nginx配置https","uri":"/aliyun_nginx_https/"},{"categories":["代理"],"content":"访问GitHub慢，下载慢的解决办法。 ","date":"2020-06-01","objectID":"/git-proxy/:0:0","tags":["windows","git","proxy"],"title":"配置git代理","uri":"/git-proxy/"},{"categories":["代理"],"content":"ssh-socket代理 创建config文件 vi ~/.ssh/config # 当然你也可以手动在 C:\\Users\\Username\\.ssh 下创建 config 文件 文件写入如下内容 # 这里的 -a none 是 NO-AUTH 模式，参见 https://bitbucket.org/gotoh/connect/wiki/Home 中的 More detail 一节 ProxyCommand connect -S 127.0.0.1:1080 -a none %h %p Host github.com User git Port 22 Hostname github.com # 注意修改路径为你的路径 IdentityFile \"C:\\Users\\zhang\\.ssh\\id_rsa\" TCPKeepAlive yes Host ssh.github.com User git Port 443 Hostname ssh.github.com # 注意修改路径为你的路径 IdentityFile \"C:\\Users\\zhang\\.ssh\\id_rsa\" TCPKeepAlive yes 参考文章： https://upupming.site/2019/05/09/git-ssh-socks-proxy/ ","date":"2020-06-01","objectID":"/git-proxy/:1:0","tags":["windows","git","proxy"],"title":"配置git代理","uri":"/git-proxy/"},{"categories":["代理"],"content":"http/https-http或socket代理 git 设置和取消代理 git config --global https.proxy http://127.0.0.1:1080 git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy https://127.0.0.1:1080 git config --global https.proxy 'socks5://127.0.0.1:1080' git config --global --unset http.proxy git config --global --unset https.proxy 参考： https://gist.github.com/laispace/666dd7b27e9116faece6 ","date":"2020-06-01","objectID":"/git-proxy/:2:0","tags":["windows","git","proxy"],"title":"配置git代理","uri":"/git-proxy/"},{"categories":["代理"],"content":"参考 https://gist.github.com/chuyik/02d0d37a49edc162546441092efae6a1 ","date":"2020-06-01","objectID":"/git-proxy/:3:0","tags":["windows","git","proxy"],"title":"配置git代理","uri":"/git-proxy/"},{"categories":["工具"],"content":"维基百科 ","date":"2020-04-04","objectID":"/nextcloud/:1:0","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"Nextcloud Nextcloud是一套用于创建网络硬盘的客户端－服务器软件。其功能与Dropbox相近，但Nextcloud是自由及开放源代码软件，每个人都可以在私人服务器上安装并运行它。 与Dropbox等专有服务相比，Nextcloud的开放架构让用户可以利用应用程序的方式在服务器上新增额外的功能，并让用户可以完全掌控自己的数据。 ownCloud原先的开发者弗兰克·卡利切创建了ownCloud的分支——Nextcloud，继而让卡利切与其他原先的ownCloud团队成员持续积极地开发。 ","date":"2020-04-04","objectID":"/nextcloud/:1:1","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"特性 Nextcloud的文件存储在一般的目录结构中，并可透过WebDAV访问。用户的文件会在传输时加密。Nextcloud可与在Windows（Windows XP、Vista、7与8）、macOS（10.6或更新版本）或是多种Linux散布版上运行的客户端同步。 Nextcloud用户可以管理日历（使用CalDAV）、联系人（CardDAV）、计划工作与流媒体（Ampache）。 从管理的角度来看，Nextcloud允许用户与组群管理（透过OpenID或LDAP）。透过用户间与／或组群间的读／写权限调整达到分享文件的目的。另外，Nextcloud的用户可以创建公开的URL来分享文件。也可以记录与文件相关的动作，以及利用文件访问规则来禁止对特定文件的访问。 此外，用户也可以透过浏览器使用Nextcloud的文本编辑器、书签服务、缩略网址服务、相册、RSS阅读器与文件查看器。因为有良好的扩展性，Nextcloud可以透过鼠标点一下即可完成安装的应用程序强化其功能，并可连线至Dropbox、Google云端硬盘与Amazon S3。 ","date":"2020-04-04","objectID":"/nextcloud/:1:2","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"架构 为了让个人电脑与Nextcloud服务器同步，Windows、macOS、FreeBSD或Linux上都有客户端可以使用。行动客户端则在iOS与Android设备上提供。也可以使用浏览器访问、管理与上传任何文件与数据。任何在设置好同步的文件系统上的变更都会推送到所有链接到该用户账号的电脑与移动设备上。 Nextcloud服务器是以PHP与JavaScript脚本语言撰写。对于远程访问，它采用的是SabreDAV，其为一开放源代码的WebDAV服务器。Nextcloud可与多种数据库管理系统一同运作，包含了SQLite、MariaDB、MySQL、Oracle数据库与PostgreSQL。 ","date":"2020-04-04","objectID":"/nextcloud/:1:3","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"centos7安装 官方安装指南: https://docs.nextcloud.com/server/latest/admin_manual/installation/source_installation.html ","date":"2020-04-04","objectID":"/nextcloud/:2:0","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"环境 LSB Version: :core-4.1-amd64:core-4.1-noarch Distributor ID: CentOS Description: CentOS Linux release 7.7.1908 (Core) Release: 7.7.1908 Codename: Core PHP 7.2.27 (cli) (built: Jan 26 2020 15:49:49) ( NTS ) Server version: 5.5.64-MariaDB MariaDB Server Nextcloud 17.0.5 Nextcloud官网: https://nextcloud.com/ ","date":"2020-04-04","objectID":"/nextcloud/:2:1","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"安装httpd(apache),php,php-fpm,MariaDB 自行百度,谷歌.如果服务器上还有nginx,建议apache更改默认端口 /etc/httpd/conf/httpd.conf(我的改为7000) php-fpm默认端口9000 ps:安装php-fpm需要注意版本是否支持要安装nextcloud版本 ","date":"2020-04-04","objectID":"/nextcloud/:2:2","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"下载nextcloud https://nextcloud.com/changelog/ 下载nextcloud-17.0.5.zip,解压至/var/www /var/www/nextcloud是根目录,有index.php,在此目录下新建目录data cd /var/www/nextcloud/ mkdir data cd /var/www chmod -R 755 nextcloud/ chown -R apache:apache nextcloud/ ","date":"2020-04-04","objectID":"/nextcloud/:2:3","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"配置httpd vim /etc/httpd/conf.d/nextcloud.conf Alias /nextcloud \"/var/www/nextcloud/\" \u003cDirectory /var/www/nextcloud/\u003e Require all granted AllowOverride All Options FollowSymLinks MultiViews \u003cIfModule mod_dav.c\u003e Dav off \u003c/IfModule\u003e \u003c/Directory\u003e 重启httpd,php-fpm,访问,http://服务器地址:7000/nextcloud 安装完成,自动进入登录界面 ","date":"2020-04-04","objectID":"/nextcloud/:2:4","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"离线安装Nextcloud应用 参考文章: https://www.himstudy.net/%E6%89%8B%E5%8A%A8%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85nextcloud%E5%BA%94%E7%94%A8/ 应用官网: https://apps.nextcloud.com/ 主要操作:将对应版本的应用下载,解压到nextcloud根目录下的apps下边,然后在设置中启用. ","date":"2020-04-04","objectID":"/nextcloud/:2:5","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"客户端 官网有对应版本的客户端,下载使用即可. 多平台挂载WebDAV方法的文章： https://www.leeyiding.com/archives/47/ ","date":"2020-04-04","objectID":"/nextcloud/:3:0","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"linux资源管理器挂载nextcloud nextcloud支持WebDAV 官网指南: https://docs.nextcloud.com/server/17/user_manual/files/access_webdav.html 本人用的是linux(deepin) 需要的操作:安装Nautilus,davfs2 dav://39.107.227.122:7000/nextcloud/remote.php/dav/files/admin/ 在nextcloud中可以获取地址,仔细看Nautilus连接到服务器使用的前缀换成对的前缀,输入nextcloud的用户名和密码就ok了.操作完成同步网盘,误删文件可以在回收站中恢复. 参考： https://www.moerats.com/archives/317/ sudo apt-get install davfs2 sudo mkdir /mnt/webdav sudo mount -t davfs http://39.107.227.122:7000/nextcloud/remote.php/webdav /mnt/webdav ","date":"2020-04-04","objectID":"/nextcloud/:3:1","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["工具"],"content":"win10挂载nextcloud 依旧使用WebDAV 需要安装RaiDrive,官网： https://www.raidrive.com/ 配置网页地址，用户名，密码就可以挂载到本地盘符了。 参考文章: https://www.wangzhengzhen.com/?p=1003 ","date":"2020-04-04","objectID":"/nextcloud/:3:2","tags":["nextcloud"],"title":"Nextcloud云盘","uri":"/nextcloud/"},{"categories":["linux"],"content":"官网下载源码 官网：https://www.python.org/downloads/source/ cd /opt/python/ sudo wget https://www.python.org/ftp/python/3.6.10/Python-3.6.10.tar.xz sudo xz -d Python-3.6.10.tar.xz sudo tar xvf Python-3.6.10.tar cd Python-3.6.10/ sudo ./configure --prefix=/usr/local/python3.6 sudo make sudo make install sudo ln -s /usr/local/python3.6/bin/python3 /usr/bin/python3.6 ","date":"2020-01-18","objectID":"/deepin-install-python3.6/:1:0","tags":["linux","python"],"title":"deepin编译安装Python3.6","uri":"/deepin-install-python3.6/"},{"categories":["linux"],"content":"虚拟环境 python3.6 -m venv ./env #创建虚拟环境 source env/bin/activate #激活虚拟环境 ","date":"2020-01-18","objectID":"/deepin-install-python3.6/:2:0","tags":["linux","python"],"title":"deepin编译安装Python3.6","uri":"/deepin-install-python3.6/"},{"categories":["linux"],"content":"python官方文档 https://docs.python.org/zh-cn/3/library/venv.html ","date":"2020-01-18","objectID":"/deepin-install-python3.6/:3:0","tags":["linux","python"],"title":"deepin编译安装Python3.6","uri":"/deepin-install-python3.6/"},{"categories":["linux"],"content":"安装Oh My Zsh github地址：https://github.com/ohmyzsh/ohmyzsh sudo apt install zsh sh -c \"$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" # 将 Zsh 设置为默认 Shell chsh -s /bin/zsh # 查看当前所用的 Shell echo $SHELL # 查看系统内已安装的 Shell cat /etc/shells ps:root执行此脚本只能root使用Oh My Zsh，其他用户使用需要在那个用户下执行此安装脚本 ","date":"2020-01-10","objectID":"/deepin-install-ohmyzsh/:1:0","tags":["linux","terminal"],"title":"deepin安装使用Oh My Zsh","uri":"/deepin-install-ohmyzsh/"},{"categories":["linux"],"content":"更换主题 vi ~/.zshrc #ZSH_THEME=\"robbyrussell\" ZSH_THEME=\"agnoster\" #ZSH_THEME=\"amuse\" #ZSH_THEME=\"fishy\" #ZSH_THEME=\"ys\" source ~/.zshrc ","date":"2020-01-10","objectID":"/deepin-install-ohmyzsh/:2:0","tags":["linux","terminal"],"title":"deepin安装使用Oh My Zsh","uri":"/deepin-install-ohmyzsh/"},{"categories":["linux"],"content":"agnoster主题箭头无法正常显示 检查是否安装PowerlineSymbols字体 如果没有安装,官方安装文档https://powerline.readthedocs.io/en/latest/installation.html 在终端选择能够正常显示箭头的字体 PowerlineSymbols,DejaVu Sans Mono 安装字体参考： https://github.com/powerline/fonts 比如： sudo apt-get install fonts-powerline，以GitHub为准。 deepin 15.11为例,系统已经装好字体了,但是没有正常显示箭头,在终端尝试哪个字体能够正常显示. ","date":"2020-01-10","objectID":"/deepin-install-ohmyzsh/:3:0","tags":["linux","terminal"],"title":"deepin安装使用Oh My Zsh","uri":"/deepin-install-ohmyzsh/"},{"categories":["linux"],"content":"speedtest-cli命令 speedtest-cli是一个使用python编写的命令行脚本，通过调用speedtest.net测试上下行的接口来完成速度测试 linux命令大全：https://man.linuxde.net/speedtest-cli github地址：https://github.com/sivel/speedtest-cli ","date":"2020-01-07","objectID":"/speedtest-cli/:1:0","tags":["speedtest"],"title":"命令行下测试服务器外网速度speedtest-cli","uri":"/speedtest-cli/"},{"categories":["linux"],"content":"使用方式 自己看作者的README.md 此处列一个简单的方法 wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py chmod +x speedtest-cli 命令 ./speedtest-cli -h 打印帮助信息 ./speedtest-cli --share 测速 ","date":"2020-01-07","objectID":"/speedtest-cli/:2:0","tags":["speedtest"],"title":"命令行下测试服务器外网速度speedtest-cli","uri":"/speedtest-cli/"},{"categories":["linux"],"content":"百度百科 lrzsz是一款在linux里可代替ftp上传和下载的程序。 ","date":"2020-01-07","objectID":"/lrzsz/:1:0","tags":["lrzsz"],"title":"Lrzsz用于小文件的上传下载","uri":"/lrzsz/"},{"categories":["linux"],"content":"使用方法 centos服务器，可直接yum -y install lrzsz 程序会自动安装好，然后如你要下载则sz [找到你要下载的文件] 如果你要上传，则rz 浏览找到你本机要上传的文件。需要注意的事这个命令无法在putty界面使用哦！ ","date":"2020-01-07","objectID":"/lrzsz/:2:0","tags":["lrzsz"],"title":"Lrzsz用于小文件的上传下载","uri":"/lrzsz/"},{"categories":["linux"],"content":"注意 deepin-terminal：使用命令出现乱码，需要用鼠标右击终端然后点击上传文件、下载文件。 ","date":"2020-01-07","objectID":"/lrzsz/:3:0","tags":["lrzsz"],"title":"Lrzsz用于小文件的上传下载","uri":"/lrzsz/"},{"categories":["linux"],"content":"维基百科 Nginx是异步框架的网页服务器，也可以用作反向代理、负载平衡器和HTTP缓存。 ","date":"2020-01-05","objectID":"/linux-nginx/:1:0","tags":["nginx"],"title":"linux安装并配置nginx","uri":"/linux-nginx/"},{"categories":["linux"],"content":"安装 官网：https://www.nginx.com/ 官网安装文档：http://nginx.org/en/docs/install.html 安装完成：http://127.0.0.1/ ","date":"2020-01-05","objectID":"/linux-nginx/:2:0","tags":["nginx"],"title":"linux安装并配置nginx","uri":"/linux-nginx/"},{"categories":["linux"],"content":"管理命令 systemctl restart nginx.service 重启 systemctl status nginx.service 查看运行状态 systemctl start nginx.service 启动 systemctl stop nginx.service 关闭 systemctl enable nginx.service 开机自启 systemctl disable nginx.service 关闭开机自启 ","date":"2020-01-05","objectID":"/linux-nginx/:3:0","tags":["nginx"],"title":"linux安装并配置nginx","uri":"/linux-nginx/"},{"categories":["linux"],"content":"默认配置文件 以CentOS/7.3.1611、 nginx/1.12.2为例： 默认配置：/etc/nginx/nginx.conf # For more information on configuration, see: # * Official English Documentation: http://nginx.org/en/docs/ # * Official Russian Documentation: http://nginx.org/ru/docs/ #user nginx; user root; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; # Load dynamic modules. See /usr/share/nginx/README.dynamic. include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-streamo; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; autoindex on; autoindex_exact_size off; autoindex_localtime on; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } # Settings for a TLS enabled server. # # server { # listen 443 ssl http2 default_server; # listen [::]:443 ssl http2 default_server; # server_name _; # root /usr/share/nginx/html; # # ssl_certificate \"/etc/pki/nginx/server.crt\"; # ssl_certificate_key \"/etc/pki/nginx/private/server.key\"; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 10m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # # # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; # # location / { # } # # error_page 404 /404.html; # location = /40x.html { # } # # error_page 500 502 503 504 /50x.html; # location = /50x.html { # } # } } 自己新加的conf可以放在cd /etc/nginx/conf.d目录下 ","date":"2020-01-05","objectID":"/linux-nginx/:4:0","tags":["nginx"],"title":"linux安装并配置nginx","uri":"/linux-nginx/"},{"categories":["linux"],"content":"自定义的配置 zhang.conf server { listen 5000 default_server; listen [::]:5000 default_server; server_name _; charset utf-8; root /root/nginxroot; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; autoindex on; autoindex_exact_size off; autoindex_localtime on; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 打开：http://127.0.0.1:5000/ ","date":"2020-01-05","objectID":"/linux-nginx/:5:0","tags":["nginx"],"title":"linux安装并配置nginx","uri":"/linux-nginx/"},{"categories":["工具"],"content":"简介 SimpleHTTPServerWithUpload.py是简单的上传下载的脚本 ","date":"2020-01-04","objectID":"/simplehttpserverwithupload/:1:0","tags":["python","tool"],"title":"SimpleHTTPServerWithUpload","uri":"/simplehttpserverwithupload/"},{"categories":["工具"],"content":"python2 ","date":"2020-01-04","objectID":"/simplehttpserverwithupload/:2:0","tags":["python","tool"],"title":"SimpleHTTPServerWithUpload","uri":"/simplehttpserverwithupload/"},{"categories":["工具"],"content":"github地址 https://gist.github.com/UniIsland/3346170 ","date":"2020-01-04","objectID":"/simplehttpserverwithupload/:2:1","tags":["python","tool"],"title":"SimpleHTTPServerWithUpload","uri":"/simplehttpserverwithupload/"},{"categories":["工具"],"content":"使用方法 方法一 python SimpleHTTPServerWithUpload.py 8050 8050为端口号，不写端口默认为8000 方法二 python -m SimpleHTTPServerWithUpload 8050 8050为端口号，不写端口默认为8000 访问：http://127.0.0.1:8050/ ","date":"2020-01-04","objectID":"/simplehttpserverwithupload/:2:2","tags":["python","tool"],"title":"SimpleHTTPServerWithUpload","uri":"/simplehttpserverwithupload/"},{"categories":["工具"],"content":"python3 ","date":"2020-01-04","objectID":"/simplehttpserverwithupload/:3:0","tags":["python","tool"],"title":"SimpleHTTPServerWithUpload","uri":"/simplehttpserverwithupload/"},{"categories":["工具"],"content":"github地址 https://gist.github.com/touilleMan/eb02ea40b93e52604938 ","date":"2020-01-04","objectID":"/simplehttpserverwithupload/:3:1","tags":["python","tool"],"title":"SimpleHTTPServerWithUpload","uri":"/simplehttpserverwithupload/"},{"categories":["工具"],"content":"使用方法 python SimpleHTTPServerWithUpload.py 端口为8000 ","date":"2020-01-04","objectID":"/simplehttpserverwithupload/:3:2","tags":["python","tool"],"title":"SimpleHTTPServerWithUpload","uri":"/simplehttpserverwithupload/"},{"categories":["linux"],"content":"安装v2ray 官网：https://www.v2ray.com/ (被墙,如果可以，不明白的多看官网) github地址：https://github.com/v2ray/v2ray-core 在root用户环境下运行 yum 或 apt-get 安装v2ray 或者执行安装脚本bash \u003c(curl -L -s https://install.direct/go.sh) 此脚本会自动安装以下文件： /usr/bin/v2ray/v2ray：V2Ray 程序； /usr/bin/v2ray/v2ctl：V2Ray 工具； /etc/v2ray/config.json：配置文件； /usr/bin/v2ray/geoip.dat：IP 数据文件 /usr/bin/v2ray/geosite.dat：域名数据文件 此脚本会配置自动运行脚本。自动运行脚本会在系统重启之后，自动运行 V2Ray。 脚本运行完成后，你需要： 编辑 /etc/v2ray/config.json 文件来配置你需要的代理方式； config.json { \"inbound\": { \"port\": 1080, \"protocol\": \"socks\", \"domainOverride\": [\"tls\",\"http\"], \"settings\": { \"auth\": \"noauth\" } }, \"outbound\": { \"protocol\": \"vmess\", \"settings\": { \"vnext\": [ { \"address\": \"216.244.76.219\", \"port\": 54321, \"users\": [ { \"id\": \"3cf35a68-ea46-11e9-9cab-003048d37a3c\", \"alterId\": 64, \"security\": \"aes-128-gcm\" } ] } ] }, \"streamSettings\": { \"network\": \"tcp\", \"security\": \"aes-128-gcm\" } } } 运行 service v2ray start 来启动 V2Ray 进程； 之后可以使用 service v2ray start|stop|status|reload|restart|force-reload 控制 V2Ray 的运行。 或者使用 systemctl status v2ray.service systemctl start v2ray.service systemctl stop v2ray.service systemctl restart v2ray.service ","date":"2020-01-04","objectID":"/linux-v2ray-client/:1:0","tags":["v2ray"],"title":"linux使用v2ray作为客户端","uri":"/linux-v2ray-client/"},{"categories":["linux"],"content":"图形客户端(推荐:支持订阅) Windows v2rayN(第三方): https://github.com/2dust/v2rayN/releases/latest 下载v2rayN-Core.zip Linux Qv2ray(第三方): https://github.com/lhy0403/Qv2ray/releases 下载Qv2ray.v2.4.1.linux-x64.AppImage,添加权限chmod 755 Qv2ray.v2.4.1.linux-x64.AppImage,双击便可执行 具体配置参考文章:https://linger.ink/2020/linux-qv2ray-usage Mac v2rayX(第三方): https://github.com/insisttech/v2rayX-copy/releases v2rayU(第三方): https://github.com/yanue/V2rayU/releases ps:由于是第三方依赖v2ray,需要指定下载的v2ray的路径,v2ray:https://github.com/v2ray/v2ray-core/releases ,下载v2ray-linux-64.zip ","date":"2020-01-04","objectID":"/linux-v2ray-client/:2:0","tags":["v2ray"],"title":"linux使用v2ray作为客户端","uri":"/linux-v2ray-client/"},{"categories":["linux"],"content":"免费账号 https://github.com/Alvin9999/new-pac/wiki https://www.freefq.com/ (被墙) https://github.com/ugvf2009/Miles ","date":"2020-01-04","objectID":"/linux-v2ray-client/:3:0","tags":["v2ray"],"title":"linux使用v2ray作为客户端","uri":"/linux-v2ray-client/"},{"categories":["linux"],"content":" 注意：推荐参考：https://github.com/zhangxiaofeng05/dotfiles ","date":"2020-01-02","objectID":"/vim-plugin/:0:0","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"插件管理器(Vundle.vim) ","date":"2020-01-02","objectID":"/vim-plugin/:1:0","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"安装 github地址：https://github.com/VundleVim/Vundle.vim (仔细看README.md) clone git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 修改配置文件 vim ~/.vimrc set nocompatible \" be iMproved, required filetype off \" required \" set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() \" alternatively, pass a path where Vundle should install plugins \"call vundle#begin('~/some/path/here') \" let Vundle manage Vundle, required Plugin 'VundleVim/Vundle.vim' \"plugin------------------------\" “Plugin '插件名' \"看作者的README.md，有示例 \"plugin------------------------\" \" All of your Plugins must be added before the following line call vundle#end() \" required filetype plugin indent on \" required \" To ignore plugin indent changes, instead use: \"filetype plugin on \" \" Brief help \" :PluginList - lists configured plugins \" :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate \" :PluginSearch foo - searches for foo; append `!` to refresh local cache \" :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal \" \" see :h vundle for more details or wiki for FAQ \" Put your non-Plugin stuff after this line ","date":"2020-01-02","objectID":"/vim-plugin/:1:1","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"Install Plugins Launch vim and run :PluginInstall To install from command line: vim +PluginInstall +qall ","date":"2020-01-02","objectID":"/vim-plugin/:1:2","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"安装NERDTree ","date":"2020-01-02","objectID":"/vim-plugin/:2:0","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"安装此插件需要安装插件管理器 github地址：https://github.com/preservim/nerdtree (仔细看README.md) clone git clone https://github.com/scrooloose/nerdtree.git ~/.vim/bundle/nerdtree 修改配置文件 vim ~/.vimrc set nocompatible \" be iMproved, required filetype off \" required \" set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() \" alternatively, pass a path where Vundle should install plugins \"call vundle#begin('~/some/path/here') \" let Vundle manage Vundle, required Plugin 'VundleVim/Vundle.vim' \"plugin------------------------\" Plugin 'scrooloose/nerdtree' \"新加的 \"plugin------------------------\" \"lionng set start--------------\" \"[Ctrl + n] to open NERDTree \"新加的 不设此快捷键需要在vim中输入:NERDTree map \u003cC-n\u003e :NERDTreeToggle\u003cCR\u003e \"新加的 \"lionng set end----------------\" \" All of your Plugins must be added before the following line call vundle#end() \" required filetype plugin indent on \" required \" To ignore plugin indent changes, instead use: \"filetype plugin on \" \" Brief help \" :PluginList - lists configured plugins \" :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate \" :PluginSearch foo - searches for foo; append `!` to refresh local cache \" :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal \" \" see :h vundle for more details or wiki for FAQ \" Put your non-Plugin stuff after this line ","date":"2020-01-02","objectID":"/vim-plugin/:2:1","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"Install Plugins Launch vim and run :PluginInstall To install from command line: vim +PluginInstall +qall ","date":"2020-01-02","objectID":"/vim-plugin/:2:2","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"快捷键 在NERDTree中输入？即可获取帮助。 ","date":"2020-01-02","objectID":"/vim-plugin/:3:0","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"root用户不能使用插件(解决) 在root用户下按上述描述安装 ","date":"2020-01-02","objectID":"/vim-plugin/:4:0","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"vim版本升级 为什么要升级vim版本,安装插件依赖的vim有版本要求. CentOS7 yum 升级vim 8 # 卸载老的vim yum remove vim-* -y # 下载第三方yum源 wget -P /etc/yum.repos.d/ https://copr.fedorainfracloud.org/coprs/lbiaggi/vim80-ligatures/repo/epel-7/lbiaggi-vim80-ligatures-epel-7.repo # install vim yum install vim-enhanced sudo -y # 验证vim版本 rpm -qa |grep vim ","date":"2020-01-02","objectID":"/vim-plugin/:5:0","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"代码自动补全插件 ","date":"2020-01-02","objectID":"/vim-plugin/:6:0","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"YouCompleteMe GitHub地址: https://github.com/ycm-core/YouCompleteMe Make sure you have Vim 7.4.1578 with Python 3 support. The Vim package on Fedora 27 and later and the pre-installed Vim on Ubuntu 16.04 and later are recent enough. You can see the version of Vim installed by running vim –version. If the version is too old, you may need to compile Vim from source (don’t worry, it’s easy). 重点:vim版本和vim支持python3,如果不符合,考虑编译vim源码,vim源码的GitHub地址:https://github.com/vim/vim 如有疑问,详细看插件的README vim安装YouCompleteMe挺麻烦的.本人使用的是deepin,deepin官方提供的方法:https://wiki.deepin.org/wiki/Vim 除了通过 Vundle 安装语法补全 YouCompleteMe，也可以自己手动编译安装，这里有另外一种更加简单的方法。 # 试试这个命令，看是否已经安装 vim-addons $ vim-addons # 如果没有安装 vim-addons，则需安装 vim-addon-manager $ sudo apt-get install vim-addon-manager # 开始安装 YouCompleteMe $ sudo apt-get install vim-youcompleteme # 将 YCM 加入 addons 管理器中 $ vim-addons install youcompleteme ","date":"2020-01-02","objectID":"/vim-plugin/:6:1","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"vim终极插件 ","date":"2020-01-02","objectID":"/vim-plugin/:7:0","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"SpaceVim(推荐) GitHub地址:https://github.com/SpaceVim/SpaceVim 安装很方便,使用体验也很nice.具体信息看官方文档 英文官网:https://spacevim.org/ 中文官网:https://spacevim.org/cn/ ","date":"2020-01-02","objectID":"/vim-plugin/:7:1","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["linux"],"content":"vimplus GitHub地址: https://github.com/chxuan/vimplus 一键安装脚本,很方便,支持很多linux发行版,具体信息看作者的README 注意:会删除你的vim,下载vim源码,重新编译,具体定制看install.sh ","date":"2020-01-02","objectID":"/vim-plugin/:7:2","tags":["vim"],"title":"vim安装插件","uri":"/vim-plugin/"},{"categories":["工具"],"content":"mariadb ","date":"2019-12-29","objectID":"/linux_install_phpmyadmin/:1:0","tags":["mysql","mariadb","phpmyadmin"],"title":"linux安装mariadb并配置phpmyadmin","uri":"/linux_install_phpmyadmin/"},{"categories":["工具"],"content":"维基百科 MariaDB是MySQL关系数据库管理系统的一个复刻，由社区开发，有商业支持，旨在继续保持在GNU GPL下开源。MariaDB的开发是由MySQL的一些原始开发者领导的，他们担心甲骨文公司收购MySQL后会有一些隐患。 linux现在默认的MySQL是mariadb。 ","date":"2019-12-29","objectID":"/linux_install_phpmyadmin/:1:1","tags":["mysql","mariadb","phpmyadmin"],"title":"linux安装mariadb并配置phpmyadmin","uri":"/linux_install_phpmyadmin/"},{"categories":["工具"],"content":"安装mariadb $ sudo apt-get install mariadb-server mariadb-client ","date":"2019-12-29","objectID":"/linux_install_phpmyadmin/:1:2","tags":["mysql","mariadb","phpmyadmin"],"title":"linux安装mariadb并配置phpmyadmin","uri":"/linux_install_phpmyadmin/"},{"categories":["工具"],"content":"新建用户授权 以root身份输入mariadb，进入mariadb # mariadb \u003e use mysql; # 进入mysql数据库 mysql\u003e CREATE USER 'zhang'@'localhost' IDENTIFIED BY '123456'; # zhang是用户名,123456是密码 mysql\u003e GRANT ALL PRIVILEGES ON *.* TO 'zhang'@'localhost' WITH GRANT OPTION; # 授权 mysql\u003e FLUSH PRIVILEGES; 或者(推荐下边的，可以登录，上边只能本地登录) mysql\u003e CREATE USER 'zhang'@'%' IDENTIFIED BY '123456'; mysql\u003e GRANT ALL PRIVILEGES ON *.* TO 'zhang'@'%' WITH GRANT OPTION; mysql\u003e FLUSH PRIVILEGES; 查看user信息 \u003e select user,host,password from user; 至此，可以用新建的用户登录了。 ","date":"2019-12-29","objectID":"/linux_install_phpmyadmin/:1:3","tags":["mysql","mariadb","phpmyadmin"],"title":"linux安装mariadb并配置phpmyadmin","uri":"/linux_install_phpmyadmin/"},{"categories":["工具"],"content":"phpmyadmin ","date":"2019-12-29","objectID":"/linux_install_phpmyadmin/:2:0","tags":["mysql","mariadb","phpmyadmin"],"title":"linux安装mariadb并配置phpmyadmin","uri":"/linux_install_phpmyadmin/"},{"categories":["工具"],"content":"维基百科 phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库。借由此Web接口可以成为一个简易方式输入繁杂SQL语法的较佳途径，尤其要处理大量数据的导入及导出更为方便。其中一个更大的优势在于由于phpMyAdmin跟其他PHP程序一样在网页服务器上运行，但是您可以在任何地方使用这些程序产生的HTML页面，也就是于远程管理MySQL数据库，方便的创建、修改、删除数据库及数据表。也可借由phpMyAdmin创建常用的php语法，方便编写网页时所需要的sql语法正确性。 ","date":"2019-12-29","objectID":"/linux_install_phpmyadmin/:2:1","tags":["mysql","mariadb","phpmyadmin"],"title":"linux安装mariadb并配置phpmyadmin","uri":"/linux_install_phpmyadmin/"},{"categories":["工具"],"content":"centos7安装配置phpmyadmin+nginx 安装 yum install phpMyAdmin yum install php php-fpm php-mysql php-mbstring -y /etc/nginx/conf.d/phpMyAdmin.conf server { listen 6060; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/phpMyAdmin; index index.php index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ { root phpMyAdmin; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/share/phpMyAdmin$fastcgi_script_name; include fastcgi_params; } # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } /etc/phpMyAdmin/config.inc.php \u003c?php /** * phpMyAdmin configuration file, you can use it as base for the manual * configuration. For easier setup you can use \"setup/\". * * All directives are explained in Documentation.html and on phpMyAdmin * wiki \u003chttp://wiki.phpmyadmin.net\u003e. */ /* * This is needed for cookie based authentication to encrypt password in * cookie */ $cfg['blowfish_secret'] = 'au1LXERWlgCnpaE7fS008WLYs4Xbgny0'; /* YOU MUST FILL IN THIS FOR COOKIE AUTH! */ /** * Server(s) configuration */ $i = 0; // The $cfg['Servers'] array starts with $cfg['Servers'][1]. Do not use // $cfg['Servers'][0]. You can disable a server config entry by setting host // to ''. If you want more than one server, just copy following section // (including $i incrementation) serveral times. There is no need to define // full server array, just define values you need to change. $i++; /* $cfg['Servers'][$i]['host'] = 'localhost'; // MySQL hostname or IP address $cfg['Servers'][$i]['port'] = ''; // MySQL port - leave blank for default port $cfg['Servers'][$i]['socket'] = ''; // Path to the socket - leave blank for default socket $cfg['Servers'][$i]['connect_type'] = 'tcp'; // How to connect to MySQL server ('tcp' or 'socket') $cfg['Servers'][$i]['extension'] = 'mysqli'; // The php MySQL extension to use ('mysql' or 'mysqli') $cfg['Servers'][$i]['compress'] = FALSE; // Use compressed protocol for the MySQL connection // (requires PHP \u003e= 4.3.0) $cfg['Servers'][$i]['controluser'] = ''; // MySQL control user settings // (this user must have read-only $cfg['Servers'][$i]['controlpass'] = ''; // access to the \"mysql/user\" // and \"mysql/db\" tables). // The controluser is also // used for all relational // features (pmadb) $cfg['Servers'][$i]['auth_type'] = 'cookie'; // Authentication method (config, http or cookie based)? $cfg['Servers'][$i]['user'] = ''; // MySQL user $cfg['Servers'][$i]['password'] = ''; // MySQL password (only needed // with 'config' auth_type) $cfg['Servers'][$i]['only_db'] = ''; // If set to a db-name, only // this db is displayed in left frame // It may also be an array of db-names, where sorting order is relevant. $cfg['Servers'][$i]['hide_db'] = ''; // Database name to be hidden from listings $cfg['Servers'][$i]['verbose'] = ''; // Verbose name for this host - leave blank to show the hostname $cfg['Servers'][$i]['pmadb'] = ''; // Database used for Relation, Bookmark and PDF Features // (see scripts/create_tables.sql) // - leave blank for no support // DEFAULT: 'phpmyadmin' $cfg['Servers'][$i]['bookmarktable'] = ''; // Bookmark table // - leave blank for no bookmark support // DEFAULT: 'pma_bookmark' $cfg['Servers'][$i]['relation'] = ''; // table to describe the relation between links (see doc) // - leave blank for no relation-links support // DEFAULT: 'pma_relation' $cfg['Servers'][$i]['table_info'] = ''; // table to describe the display fields // - leave blank for no display fields support // DEFAULT: 'pma_table_info' $cfg['Servers']","date":"2019-12-29","objectID":"/linux_install_phpmyadmin/:2:2","tags":["mysql","mariadb","phpmyadmin"],"title":"linux安装mariadb并配置phpmyadmin","uri":"/linux_install_phpmyadmin/"},{"categories":["工具"],"content":"deepin安装phpmyadmin+apache2 $ sudo apt-get install apache2 $ sudo apt-get install phpmyadmin ","date":"2019-12-29","objectID":"/linux_install_phpmyadmin/:2:3","tags":["mysql","mariadb","phpmyadmin"],"title":"linux安装mariadb并配置phpmyadmin","uri":"/linux_install_phpmyadmin/"},{"categories":["工具"],"content":"修改配置 位置： /etc/apache2/apache2.conf $ sudo vim /etc/apache2/apache2.conf 在文件底部加上 Include /etc/phpmyadmin/apache.conf 在地址栏输入http://localhost/phpmyadmin/ 输入用户和密码即可登录 登录后能正常使用，但底部显示默认连出错，需要将默认配置注释掉 $ sudo vi /etc/phpmyadmin/config.inc.php 注释图片的两处 目前只能连接本地数据库，端口也不能修改,下边是解决方法 修改配置 $ sudo vi /etc/phpmyadmin/config.inc.php 在文件底部加上 $cfg['AllowArbitraryServer'] = true; /* 允许自定义服务器，默认为false */ 关闭版本检查更新 修改version_check.php echo json_encode(array());//添加这一行，下边的注释掉 /* if (empty($versionDetails)) { echo json_encode(array()); } else { $latestCompatible = $versionInformation-\u003egetLatestCompatibleVersion( $versionDetails-\u003ereleases ); $version = ''; $date = ''; if ($latestCompatible != null) { $version = $latestCompatible['version']; $date = $latestCompatible['date']; } echo json_encode( array( 'version' =\u003e (! empty($version) ? $version : ''), 'date' =\u003e (! empty($date) ? $date : ''), ) ); } */ 参考地址 https://support.plesk.com/hc/en-us/articles/360005493133-Unable-to-register-remote-MySQL-server-Host-is-not-allowed-to-connect-to-this-MySQL-server ","date":"2019-12-29","objectID":"/linux_install_phpmyadmin/:2:4","tags":["mysql","mariadb","phpmyadmin"],"title":"linux安装mariadb并配置phpmyadmin","uri":"/linux_install_phpmyadmin/"},{"categories":["linux"],"content":"维基百科 https://zh.wikipedia.org/wiki/Docker Docker是一个开放源代码软件项目，让应用程序部署在软件货柜下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。 ","date":"2019-12-08","objectID":"/docker/:1:0","tags":["linux","docker"],"title":"Docker","uri":"/docker/"},{"categories":["linux"],"content":"docker官网 官网：https://www.docker.com/ 官网安装指南：https://docs.docker.com/install/ docker安装软件比较简单，很适合学习，避免了linux的各种版本安装软件的繁琐。 ","date":"2019-12-08","objectID":"/docker/:2:0","tags":["linux","docker"],"title":"Docker","uri":"/docker/"},{"categories":["linux"],"content":"Docker Hub https://hub.docker.com/ Docker Hub是一个由Docker公司负责维护的公共注册中心，它包含了超过15,000个可用来下载和构建容器的镜像，并且还提供认证、工作组结构、工作流工具（比如webhooks）、构建触发器以及私有工具（比如私有仓库可用于存储你并不想公开分享的镜像）。 ","date":"2019-12-08","objectID":"/docker/:3:0","tags":["linux","docker"],"title":"Docker","uri":"/docker/"},{"categories":["linux"],"content":"举例：docker安装MySQL 官网安装指南：https://hub.docker.com/_/mysql 举例： docker pull mysql:5.7.28 docker run -p 3306:3306 --name mysql5.7 -e MYSQL_ROOT_PASSWORD=password -d mysql:5.7.28 具参数查看官网!!! ","date":"2019-12-08","objectID":"/docker/:3:1","tags":["linux","docker"],"title":"Docker","uri":"/docker/"},{"categories":["linux"],"content":"举例：docker安装phpmyadmin 官网安装指南：https://hub.docker.com/r/phpmyadmin/phpmyadmin 举例： docker pull phpmyadmin/phpmyadmin docker run --name myadmin -d -e PMA_ARBITRARY=1 -p 6060:80 phpmyadmin/phpmyadmin 此命令安装，登录任意服务器地址端口，空格为分割 ","date":"2019-12-08","objectID":"/docker/:3:2","tags":["linux","docker"],"title":"Docker","uri":"/docker/"},{"categories":["工具"],"content":"linux环境 LSB Version: :core-4.1-amd64:core-4.1-noarch Distributor ID: CentOS Description: CentOS Linux release 7.3.1611 (Core) Release: 7.3.1611 Codename: Core ","date":"2019-12-01","objectID":"/ftp-server/:1:0","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"安装 yum install vsftpd systemctl restart vsftpd.service # 重启vsftpd systemctl stop vsftpd.service # 停止vsftpd systemctl start vsftpd.service # 启动vsftpd systemctl status vsftpd.service # 查看vsftpd的状态 ","date":"2019-12-01","objectID":"/ftp-server/:2:0","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"匿名配置 ","date":"2019-12-01","objectID":"/ftp-server/:3:0","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"服务器配置文件 位置：/etc/vsftpd/vsftpd.conf 坑：从网上购买的服务器(阿里云)要从控制台开放ftp的端口，建议放开全部端口，如果有需要限制，再限制，否则会出现登录失败的问题 防火墙：开放所需端口 ","date":"2019-12-01","objectID":"/ftp-server/:3:1","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"匿名设置：配置文件内容 anonymous_enable=YES #允许匿名登录 local_enable=YES write_enable=YES local_umask=022 #匿名上传的默认权限，匿名不能修改生效，只能上传删除 anon_upload_enable=YES #允许匿名上传 anon_mkdir_write_enable=YES anon_other_write_enable=YES dirmessage_enable=YES xferlog_enable=YES connect_from_port_20=YES xferlog_file=/var/log/xferlog xferlog_std_format=YES listen=YES listen_ipv6=NO pam_service_name=vsftpd userlist_enable=YES tcp_wrappers=YES 匿名用户的默认根目录：/var/ftp/pub 需要更改权限：chmod -R 755 /var/ftp/pub ","date":"2019-12-01","objectID":"/ftp-server/:3:2","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"客户端(deepin) 安装： sudo apt-get install vsftpd sudo apt-get install lftp ","date":"2019-12-01","objectID":"/ftp-server/:3:3","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"匿名连接ftp服务器 lftp IP ","date":"2019-12-01","objectID":"/ftp-server/:3:4","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"常用命令 lpwd 当地目录 pwd 远程目录 lcd 本地切换目录 cd 远程切换目录 mput hello.c aaa.txt 上传多个文件 -------------------------------- put 上传单个文件 mput 上传多个文件 get 下载单个文件 mget 下载多个文件 mirror 下载整个目录及其子目录 mirror -R 上传整个目录及其子目录 退出 bye、quit、exit 详细请谷歌、百度，help一下 至此，匿名用户可以用终端上传下载文件!!! ","date":"2019-12-01","objectID":"/ftp-server/:3:5","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"浏览器访问ftp服务器 在地址栏中输入ftp://服务器ip地址 ","date":"2019-12-01","objectID":"/ftp-server/:3:6","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"文件管理器访问ftp服务器 在地址栏中输入ftp://服务器ip地址 ","date":"2019-12-01","objectID":"/ftp-server/:3:7","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"让其他人下载 匿名用户不能修改文件的权限，只能上传和删除，如果要能让别人下载，需要使用用户登录服务器，为下载的文件添加执行权限 至此，可以用浏览器和文件管理器下载分享的文件了 ","date":"2019-12-01","objectID":"/ftp-server/:3:8","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"wget下载 使用wget ftp://IP地址/pub/ftp.txt 卡在PASV ... 无法连接到 查看wget的参数，使用wget --no-passive-ftp ftp://IP地址/pub/ftp.txt ","date":"2019-12-01","objectID":"/ftp-server/:3:9","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"用户名连接ftp服务器 ","date":"2019-12-01","objectID":"/ftp-server/:4:0","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"创建用户 sudo adduser ftpuser # 创建用户 sudo passwd ftpuser # 为此用户设置密码 sudo usermod -a -G ftp ftpuser # 将创建的ftpuser用户添加到ftp组 ","date":"2019-12-01","objectID":"/ftp-server/:4:1","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"服务器配置文件 位置：/etc/vsftpd/vsftpd.conf ","date":"2019-12-01","objectID":"/ftp-server/:4:2","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"配置文件内容 匿名关闭，强制实行实名 anonymous_enable=NO local_enable=YES write_enable=YES local_umask=755 dirmessage_enable=YES xferlog_enable=YES connect_from_port_20=YES xferlog_file=/var/log/xferlog xferlog_std_format=YES listen=YES listen_ipv6=NO pam_service_name=vsftpd userlist_enable=YES tcp_wrappers=YES ","date":"2019-12-01","objectID":"/ftp-server/:4:3","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"用户名登录 lftp 用户名:密码@ftp地址:传送端口（默认21） 用户的默认路径：/home/ftpuser 上传和下载不再赘述 ","date":"2019-12-01","objectID":"/ftp-server/:4:4","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"让其他人下载 在客户端上传文件后，查看文件的执行权限，下载需要执行权限，如果没有，执行chmod +x ftp.txt 通过浏览器或文件管理器访问ftp://IP地址，用户登录，即可下载 ","date":"2019-12-01","objectID":"/ftp-server/:4:5","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["工具"],"content":"wget下载 第一种方法 使用wget ftp://用户名:密码@IP地址/ftp.txt 卡在PASV ... 使用wget ftp://用户名:密码@IP地址/ftp.txt --no-passive-ftp 第二种方法 使用wget ftp://IP地址/ftp.txt --ftp-user=用户名 --ftp-password=密码 --no-passive-ftp 第三种方法 使用wget --user=ftpuser --password=passwd IP:/home/ftp.txt[绝对路径] --no-passive-ftp 这样可以下载任意位置的文件了。 注意：目录建议设成权限755，文件需要有执行权限 多使用wget -help，查看linux系统对wget参数的解释 ","date":"2019-12-01","objectID":"/ftp-server/:4:6","tags":["ftp"],"title":"ftp服务器","uri":"/ftp-server/"},{"categories":["Linux"],"content":"vim打开文件后 1、在视图模式下输入 :set paste 2、按i进入编辑模式 3、粘贴((win)Ctrl+v | Shift+Insert(linux)) 4、关闭粘贴 :set nopaste ","date":"2019-11-28","objectID":"/vim_paste/:0:0","tags":["vim"],"title":"解决vim粘贴错乱问题","uri":"/vim_paste/"},{"categories":["工具"],"content":"hugo站点 hugo官网：https://gohugo.io/ 安装和使用，先参考官网 安装：使用命令或者从GitHub下载 https://github.com/gohugoio/hugo 检查安装：$ hugo version 生成站点 $ hugo new site blogHugo 进入站点 $ cd blogHugo 使用主题(https://github.com/olOwOlo/hugo-theme-even) $ git clone https://github.com/olOwOlo/hugo-theme-even themes/even 安装主题上的说明进行配置，注意此主题生成新文件为$ hugo new post/some-content.md 本地运行预览博客 $ hugo server -D 浏览器 $ http://localhost:1313/ ","date":"2019-10-21","objectID":"/hugo_blog/:1:0","tags":["hugo","github"],"title":"hugo搭建博客，部署到GitHub","uri":"/hugo_blog/"},{"categories":["工具"],"content":"部署到GitHub 在GitHub新建仓库 username.github.io 渲染md文件 $ hugo --theme=even --baseUrl=\"https://username.github.io\" --buildDrafts 此时生成了public目录 执行命令 cd public git init git commit -m \"first commit\" git remote add origin git@github.com:username/blogHugo.git git push origin master 以后再提交，在站点执行此脚本 $ sh gitHub.sh gitHub.sh hugo --theme=even --baseUrl=\"https://username.github.io\" --buildDrafts cd public git add . git commit -m \"update\" git push origin master cd .. ","date":"2019-10-21","objectID":"/hugo_blog/:2:0","tags":["hugo","github"],"title":"hugo搭建博客，部署到GitHub","uri":"/hugo_blog/"},{"categories":["工具"],"content":"原文件放入私有仓库 第一次使用，在站点目录下 git init git add . git commit -m \"first commit\" git remote add origin git@github.com:username/blogHugo.git git push origin master 以后可以使用脚本 $ sh zhang.sh zhang.sh git add . git commit -m \"update\" git push origin master sh gitHub.sh ","date":"2019-10-21","objectID":"/hugo_blog/:3:0","tags":["hugo","github"],"title":"hugo搭建博客，部署到GitHub","uri":"/hugo_blog/"},{"categories":null,"content":"书 ","date":"2019-10-10","objectID":"/firefly/:1:0","tags":null,"title":"小工具","uri":"/firefly/"},{"categories":null,"content":"纸质书 鸟哥的linux私房菜 图解密码技术 第3版 ","date":"2019-10-10","objectID":"/firefly/:1:1","tags":null,"title":"小工具","uri":"/firefly/"},{"categories":null,"content":"在线文档 LeetCode Cookbook Go语言设计与实现 设计模式 精通比特币 第二版 货币未来：从金本位到区块链 区块链编程2020 Grokking Bitcoin ","date":"2019-10-10","objectID":"/firefly/:1:2","tags":null,"title":"小工具","uri":"/firefly/"},{"categories":null,"content":"工具 Linux命令大全 https://man.niaoge.com/ 重点：grep awk sed git-tips git技巧: https://github.com/jaywcjlove/git-tips you-get 下载媒体内容: https://github.com/soimort/you-get gitignore git忽略文件的编写: https://github.com/github/gitignore 内网穿透,端口转发工具 https://ngrok.com/ https://localtunnel.github.io/www/ ","date":"2019-10-10","objectID":"/firefly/:2:0","tags":null,"title":"小工具","uri":"/firefly/"},{"categories":null,"content":"谷歌插件 Proxy SwitchyOmega 切换代理: https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif Bitwarden - 免费密码管理器 https://chrome.google.com/webstore/detail/bitwarden-free-password-m/nngceckbapebfimnlniiiahkandclblb Infinity 新标签页 https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg 暴力猴 https://chrome.google.com/webstore/detail/violentmonkey/jinjaccalgkegednnccohejagnlnfdag 或者选择tampermonkey 文本选中复制 https://greasyfork.org/zh-CN/scripts/405130-%E6%96%87%E6%9C%AC%E9%80%89%E4%B8%AD%E5%A4%8D%E5%88%B6 AdBlock — 最佳广告拦截工具 https://chrome.google.com/webstore/detail/adblock-%E2%80%94-best-ad-blocker/gighmmpiobklfepjocnamgkkbiglidom FeHelper(前端助手) https://chrome.google.com/webstore/detail/fehelper%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8B/pkgccpejnmalmdinmhkkfafefagiiiad Google 翻译 https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb 不常用 AHA Music 识别音乐: https://chrome.google.com/webstore/detail/aha-music-music-identifie/dpacanjfikmhoddligfbehkpomnbgblf 草料二维码-快速生码和解码工具 https://chrome.google.com/webstore/detail/%E8%8D%89%E6%96%99%E4%BA%8C%E7%BB%B4%E7%A0%81/moombeodfomdpjnpocobemoiaemednkg Video Speed Controls https://chrome.google.com/webstore/detail/video-speed-controller/iihlkfggcbggmbgdkklanmfallibkhio Elasticvue https://chrome.google.com/webstore/detail/elasticvue/hkedbapjpblbodpgbajblpnlpenaebaa Octotree - GitHub code tree https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc OneTab https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall 国内网址离线安装谷歌浏览器插件参考： https://www.extfans.com/ 知乎: https://zhuanlan.zhihu.com/p/80305764 Chrome插件英雄榜: https://github.com/zhaoolee/ChromeAppHeroes ","date":"2019-10-10","objectID":"/firefly/:3:0","tags":null,"title":"小工具","uri":"/firefly/"},{"categories":null,"content":"喜欢的句子 根本没有什么岁月静好，只是有人替你负重前行. 代码会告诉你怎么做,注释会告诉你为何如此. 知识学会了，终身都是自己的，没有学会，那些知识都是身外之物。 ARTS 是 Algorithm、Review、Technique、Share 的简称，即每周至少做一个 leetcode 的算法题，阅读并点评至少一篇英文技术文章，学习至少一个技术技巧，至少分享一篇有观点和思考的技术文章 ","date":"2019-10-10","objectID":"/firefly/:4:0","tags":null,"title":"小工具","uri":"/firefly/"},{"categories":null,"content":"联系我 CSDN QQ ","date":"2019-09-27","objectID":"/about/:1:0","tags":null,"title":"about","uri":"/about/"},{"categories":["设计模式"],"content":"百度百科 ","date":"2019-08-30","objectID":"/memento-pattern/:0:0","tags":["pattern"],"title":"行为型模式-备忘录模式","uri":"/memento-pattern/"},{"categories":["设计模式"],"content":"备忘录模式 备忘录模式是一种软件设计模式：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 ","date":"2019-08-30","objectID":"/memento-pattern/:1:0","tags":["pattern"],"title":"行为型模式-备忘录模式","uri":"/memento-pattern/"},{"categories":["设计模式"],"content":"基本介绍 备忘录模式（Memento Pattern）又叫做快照模式（Snapshot Pattern）或Token模式，是GoF的23种设计模式之一，属于行为模式。 定义：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 涉及角色： Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator可以根据需要决定Memento存储自己的哪些内部状态。 Memento(备忘录)：负责存储Originator对象的内部状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。 Caretaker(管理者):负责备忘录Memento，不能对Memento的内容进行访问或者操作。 备忘录模式的优点和缺点 一、 备忘录模式的优点 有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时， 使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。 本模式简化了发起人类。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需 要的这些状态的版本。 二、 备忘录模式的缺点： 如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。 当负责人角色将一个备忘录 存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。 当发起人角色的状态改变的时候，有可能这个协议无效。如果状态改变的成功率不高的话，不如采取“假如”协议模式。 例子 Memento 备忘录存储原发器对象的内部状态。 public class Memento { private String state; public Memento(String state) { this.state = state; } public String getState() { return state; } public void setState(String state) { this.state = state; } } Originator 原发器创建一个备忘录,用以记录当前时刻的内部状态。 使用备忘录恢复内部状态 public class Originator { private String state; public String getState() { return state; } public void setState(String state) { this.state = state; } public Memento createMemento(){ return new Memento(state); } public void setMemento(Memento memento){ state=memento.getState(); } public void showState(){ System.out.println(state); } } Caretaker 负责保存好备忘录。 不能对备忘录的内部进行操作或检查。 public class Caretaker { private Memento memento; public Memento getMemento() { return memento; } public void setMemento(Memento memento) { this.memento = memento; } } Test public class Test { public static void main(String[] args) { Originator org = new Originator(); org.setState(\"开会中\"); Caretaker ctk = new Caretaker(); ctk.setMemento(org.createMemento());//将数据封装在Caretaker org.setState(\"睡觉中\"); org.showState(); org.setMemento(ctk.getMemento()); org.showState(); } } 运行结果 睡觉中 开会中 ","date":"2019-08-30","objectID":"/memento-pattern/:2:0","tags":["pattern"],"title":"行为型模式-备忘录模式","uri":"/memento-pattern/"},{"categories":["设计模式"],"content":"百度百科 ","date":"2019-08-29","objectID":"/interpreter-pattern/:0:0","tags":["pattern"],"title":"行为型模式-解释器模式","uri":"/interpreter-pattern/"},{"categories":["设计模式"],"content":"Interpreter模式 Interpreter(解释器)模式是一种特殊的设计模式，它建立一个解释器（Interpreter），对于特定的计算机程序设计语言，用来解释预先定义的文法。简单地说，Interpreter模式是一种简单的语法解释器构架。 Interpreter模式，即解释器模式。 解释器模式属于行为模式，Gof是这样定义的：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 解释器模式需要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 实例应用：正则表达式 例子 AbstractExpression(抽象表达式) 声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。 public abstract class Expression { abstract void interpret(Context ctx); } TerminalExpression(终结符表达式) 实现与文法中的终结符相关联的解释操作。 一个句子中的每个终结符需要该类的一个实例。 public class SimpleExpression extends Expression { @Override void interpret(Context ctx) { System.out.println(\"这是普通解析器\"); } } NonterminalExpression(非终结符表达式) 为文法中的非终结符实现解释(Interpret)操作。 public class AdvanceExpression extends Expression { @Override void interpret(Context ctx) { System.out.println(\"这是高级解析器\"); } } Context（上下文） 包含解释器之外的一些全局信息。 import java.util.ArrayList; import java.util.List; public class Context { private String content; private List list = new ArrayList(); public String getContent() { return content; } public void setContent(String content) { this.content = content; } public void add(Expression eps){ list.add(eps); } public List getList(){ return list; } } Client（客户） 构建(或被给定)表示该文法定义的语言中某个特定的句子的抽象语法树。 该抽象语法树由NonterminalExpression和TerminalExpression的实例装配而成。调用解释操作。 public class Test { public static void main(String[] args) { Context ctx = new Context(); ctx.add(new SimpleExpression()); ctx.add(new AdvanceExpression()); ctx.add(new SimpleExpression()); for(Object eps: ctx.getList()){ ((Expression)eps).interpret(ctx); } } } 运行结果 这是普通解析器 这是高级解析器 这是普通解析器 ","date":"2019-08-29","objectID":"/interpreter-pattern/:1:0","tags":["pattern"],"title":"行为型模式-解释器模式","uri":"/interpreter-pattern/"},{"categories":["设计模式"],"content":"百度百科 ","date":"2019-08-29","objectID":"/composite-pattern/:0:0","tags":["pattern"],"title":"结构型模式-组合模式","uri":"/composite-pattern/"},{"categories":["设计模式"],"content":"组合模式 组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。掌握组合模式的重点是要理解清楚 “部分/整体” 还有 ”单个对象“ 与 “组合对象” 的含义。 组合模式可以让客户端像修改配置文件一样简单的完成本来需要流程控制语句来完成的功能。 经典案例：系统目录结构，网站导航结构等。 ","date":"2019-08-29","objectID":"/composite-pattern/:1:0","tags":["pattern"],"title":"结构型模式-组合模式","uri":"/composite-pattern/"},{"categories":["设计模式"],"content":"组合模式概述 组合模式(Composite Pattern) 组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。 有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。 组合模式让你可以优化处理递归或分级数据结构。有许多关于分级数据结构的例子，使得组合模式非常有用武之地。关于分级数据结构的一个普遍性的例子是你每次使用电脑时所遇到的:文件系统。文件系统由目录和文件组成。每个目录都可以装内容。目录的内容可以是文件，也可以是目录。按照这种方式，计算机的文件系统就是以递归结构来组织的。如果你想要描述这样的数据结构，那么你可以使用组合模式Composite。 定义 (GoF《设计模式》)：将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 涉及角色： Component 是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。 Leaf 在组合中表示叶子结点对象，叶子结点没有子结点。 Composite 定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。 适用性 以下情况下适用Composite模式： 你想表示对象的部分-整体层次结构 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 ","date":"2019-08-29","objectID":"/composite-pattern/:2:0","tags":["pattern"],"title":"结构型模式-组合模式","uri":"/composite-pattern/"},{"categories":["设计模式"],"content":"总结 组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以像处理简单元素一样来处理复杂元素。 如果你想要创建层次结构，并可以在其中以相同的方式对待所有元素，那么组合模式就是最理想的选择。本章使用了一个文件系统的例子来举例说明了组合模式的用途。在这个例子中，文件和目录都执行相同的接口，这是组合模式的关键。通过执行相同的接口，你就可以用相同的方式对待文件和目录，从而实现将文件或者目录储存为目录的子级元素。 例子 Component 为组合中的对象声明接口。 在适当的情况下，实现所有类共有接口的缺省行为。 声明一个接口用于访问和管理Component的子组件。 import java.util.List; public abstract class Employer { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public abstract void add(Employer employer); public abstract void delete(Employer employer); public List employers; public void printInfo(){ System.out.println(name); } public List getEmployers(){ return this.employers; } } Leaf 在组合中表示叶节点对象，叶节点没有子节点。 在组合中定义节点对象的行为。 public class Programer extends Employer { public Programer(String name) { setName(name); employers=null;//程序员，表示没有下属了 } @Override public void add(Employer employer) { } @Override public void delete(Employer employer) { } } public class ProjectAssistant extends Employer { public ProjectAssistant(String name) { setName(name); employers=null;//项目助理，表示没有下属了 } @Override public void add(Employer employer) { } @Override public void delete(Employer employer) { } } Composite import java.util.ArrayList; public class ProjectManager extends Employer { public ProjectManager(String name) { setName(name); employers = new ArrayList(); } @Override public void add(Employer employer) { employers.add(employer); } @Override public void delete(Employer employer) { employers.remove(employer); } } Test import java.util.List; public class Test { public static void main(String[] args) { Employer pm = new ProjectManager(\"项目经理\"); Employer pa = new ProjectAssistant(\"项目助理\"); Employer programer1 = new Programer(\"程序员1\"); Employer programer2 = new Programer(\"程序员2\"); pm.add(pa); pm.add(programer1); pm.add(programer2); List ems = pm.getEmployers(); for (Object em :ems){ System.out.println(((Employer) em).getName()); } } } 运行结果 项目助理 程序员1 程序员2 ","date":"2019-08-29","objectID":"/composite-pattern/:3:0","tags":["pattern"],"title":"结构型模式-组合模式","uri":"/composite-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-29","objectID":"/visitor-pattern/:0:0","tags":["pattern"],"title":"行为型模式-访问者模式","uri":"/visitor-pattern/"},{"categories":["设计模式"],"content":"访问者模式 访问者模式是一种将算法与对象结构分离的软件设计模式。 这个模式的基本想法如下：首先我们拥有一个由许多对象构成的对象结构，这些对象的类都拥有一个accept方法用来接受访问者对象；访问者是一个接口，它拥有一个visit方法，这个方法对访问到的对象结构中不同类型的元素作出不同的反应；在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施accept方法，在每一个元素的accept方法中回调访问者的visit方法，从而使访问者得以处理对象结构的每一个元素。我们可以针对对象结构设计不同的实在的访问者类来完成不同的操作。 访问者模式使得我们可以在传统的单分派语言（如Smalltalk、Java和C++）中模拟双分派技术。对于支持多分派的语言（如CLOS），访问者模式已经内置于语言特性之中了，从而不再重要。 ","date":"2019-08-29","objectID":"/visitor-pattern/:1:0","tags":["pattern"],"title":"行为型模式-访问者模式","uri":"/visitor-pattern/"},{"categories":["设计模式"],"content":"Java interface Visitor { void visit(Wheel wheel); void visit(Engine engine); void visit(Body body); void visit(Car car); } class Wheel { private String name; Wheel(String name) { this.name = name; } String getName() { return this.name; } void accept(Visitor visitor) { visitor.visit(this); } } class Engine { void accept(Visitor visitor) { visitor.visit(this); } } class Body { void accept(Visitor visitor) { visitor.visit(this); } } class Car { private Engine engine = new Engine(); private Body body = new Body(); private Wheel[] wheels = { new Wheel(\"front left\"), new Wheel(\"front right\"), new Wheel(\"back left\") , new Wheel(\"back right\") }; void accept(Visitor visitor) { visitor.visit(this); engine.accept(visitor); body.accept(visitor); for (int i = 0; i \u003c wheels.length; ++ i) wheels[i].accept(visitor); } } class PrintVisitor implements Visitor { public void visit(Wheel wheel) { System.out.println(\"Visiting \" + wheel.getName() + \" wheel\"); } public void visit(Engine engine) { System.out.println(\"Visiting engine\"); } public void visit(Body body) { System.out.println(\"Visiting body\"); } public void visit(Car car) { System.out.println(\"Visiting car\"); } } public class VisitorDemo { static public void main(String[] args) { Car car = new Car(); Visitor visitor = new PrintVisitor(); car.accept(visitor); } } 运行结果： Visiting car Visiting engine Visiting body Visiting front left wheel Visiting front right wheel Visiting back left wheel Visiting back right wheel ","date":"2019-08-29","objectID":"/visitor-pattern/:2:0","tags":["pattern"],"title":"行为型模式-访问者模式","uri":"/visitor-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-29","objectID":"/template-method-pattern/:0:0","tags":["pattern"],"title":"行为型模式-模板方法","uri":"/template-method-pattern/"},{"categories":["设计模式"],"content":"模板方法 模板方法模型是一种行为设计模型。模板方法是一个定义在父类别的方法，在模板方法中会呼叫多个定义在父类别的其他方法，而这些方法有可能只是抽象方法并没有实作，模板方法仅决定这些抽象方法的执行顺序，这些抽象方法的实作由子类别负责，并且子类别不允许覆写模板方法。 ","date":"2019-08-29","objectID":"/template-method-pattern/:1:0","tags":["pattern"],"title":"行为型模式-模板方法","uri":"/template-method-pattern/"},{"categories":["设计模式"],"content":"用法 模板方法模式多用在： 某些类别的算法中，实做了相同的方法，造成程式码的重复。 控制子类别必须遵守的一些事项。 … ","date":"2019-08-29","objectID":"/template-method-pattern/:2:0","tags":["pattern"],"title":"行为型模式-模板方法","uri":"/template-method-pattern/"},{"categories":["设计模式"],"content":"Java /** * An abstract class that is common to several games in * which players play against the others, but only one is * playing at a given time. */ abstract class Game { private int playersCount; abstract void initializeGame(); abstract void makePlay(int player); abstract boolean endOfGame(); abstract void printWinner(); /* A template method : */ final void playOneGame(int playersCount) { this.playersCount = playersCount; initializeGame(); int j = 0; while (!endOfGame()){ makePlay(j); j = (j + 1) % playersCount; } printWinner(); } } //Now we can extend this class in order to implement actual games: class Monopoly extends Game { /* Implementation of necessary concrete methods */ void initializeGame() { // ... } void makePlay(int player) { // ... } boolean endOfGame() { // ... } void printWinner() { // ... } /* Specific declarations for the Monopoly game. */ // ... } class Chess extends Game { /* Implementation of necessary concrete methods */ void initializeGame() { // ... } void makePlay(int player) { // ... } boolean endOfGame() { // ... } void printWinner() { // ... } /* Specific declarations for the chess game. */ // ... } public class Player { public static void main(String[] args) { Game chessGame = new Chess(); chessGame.initializeGame(); chessGame.playOneGame(1); //call template method } } 例子 AbstractClass 定义抽象的原语操作（primitiveoperation），具体的子类将重定义它们以实现一个算法的各步骤。 实现一个模板方法,定义一个算法的骨架。 该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作。 public abstract class Template { public abstract void print(); public void update(){ System.out.println(\"开始打印---\"); for (int i=0;i\u003c10;i++){ print(); } } } ConcreteClass 实现原语操作以完成算法中与特定子类相关的步骤。 public class TemplateConcrete extends Template { @Override public void print() { System.out.println(\"这是子类的实现\"); } } Test public class Test { public static void main(String[] args) { Template temp = new TemplateConcrete(); temp.update(); } } 运行结果： 开始打印--- 这是子类的实现 这是子类的实现 这是子类的实现 这是子类的实现 这是子类的实现 这是子类的实现 这是子类的实现 这是子类的实现 这是子类的实现 这是子类的实现 ","date":"2019-08-29","objectID":"/template-method-pattern/:3:0","tags":["pattern"],"title":"行为型模式-模板方法","uri":"/template-method-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-29","objectID":"/strategy-pattern/:0:0","tags":["pattern"],"title":"行为型模式-策略模式","uri":"/strategy-pattern/"},{"categories":["设计模式"],"content":"策略模式 策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。 策略模式： 定义了一族算法（业务规则）； 封装了每个算法； 这族的算法可互换代替（interchangeable）。 ","date":"2019-08-29","objectID":"/strategy-pattern/:1:0","tags":["pattern"],"title":"行为型模式-策略模式","uri":"/strategy-pattern/"},{"categories":["设计模式"],"content":"Java //StrategyExample test application class StrategyExample { public static void main(String[] args) { Context context; // Three contexts following different strategies context = new Context(new FirstStrategy()); context.execute(); context = new Context(new SecondStrategy()); context.execute(); context = new Context(new ThirdStrategy()); context.execute(); } } // The classes that implement a concrete strategy should implement this // The context class uses this to call the concrete strategy interface Strategy { void execute(); } // Implements the algorithm using the strategy interface class FirstStrategy implements Strategy { public void execute() { System.out.println(\"Called FirstStrategy.execute()\"); } } class SecondStrategy implements Strategy { public void execute() { System.out.println(\"Called SecondStrategy.execute()\"); } } class ThirdStrategy implements Strategy { public void execute() { System.out.println(\"Called ThirdStrategy.execute()\"); } } // Configured with a ConcreteStrategy object and maintains a reference to a Strategy object class Context { Strategy strategy; // Constructor public Context(Strategy strategy) { this.strategy = strategy; } public void execute() { this.strategy.execute(); } } 运行结果： Called FirstStrategy.execute() Called SecondStrategy.execute() Called ThirdStrategy.execute() ","date":"2019-08-29","objectID":"/strategy-pattern/:2:0","tags":["pattern"],"title":"行为型模式-策略模式","uri":"/strategy-pattern/"},{"categories":["设计模式"],"content":"百度百科 ","date":"2019-08-29","objectID":"/state-pattern/:0:0","tags":["pattern"],"title":"行为型模式-状态模式","uri":"/state-pattern/"},{"categories":["设计模式"],"content":"状态模式 (State Pattern)是设计模式的一种，属于行为模式。 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类 ","date":"2019-08-29","objectID":"/state-pattern/:1:0","tags":["pattern"],"title":"行为型模式-状态模式","uri":"/state-pattern/"},{"categories":["设计模式"],"content":"定义 (源于Design Pattern)：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。 状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。 ","date":"2019-08-29","objectID":"/state-pattern/:2:0","tags":["pattern"],"title":"行为型模式-状态模式","uri":"/state-pattern/"},{"categories":["设计模式"],"content":"意图 允许一个对象在其内部状态改变时改变它的行为 ","date":"2019-08-29","objectID":"/state-pattern/:3:0","tags":["pattern"],"title":"行为型模式-状态模式","uri":"/state-pattern/"},{"categories":["设计模式"],"content":"适用场景 一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。 一个操作中含有庞大的多分支结构，并且这些分支决定于对象的状态。 例子 State 定义一个接口以封装与Context的一个特定状态相关的行为。 public interface Weather { String getWeather(); } Context 定义客户感兴趣的接口。 维护一个ConcreteState子类的实例，这个实例定义当前状态。 public class Context { private Weather weather; public Weather getWeather() { return weather; } public void setWeather(Weather weather) { this.weather = weather; } public String weatherMessage(){ return weather.getWeather(); } } ConcreteStatesubclasses 每一子类实现一个与Context的一个状态相关的行为。 public class Rain implements Weather { @Override public String getWeather() { return \"下雨\"; } } public class Sunshine implements Weather { @Override public String getWeather() { return \"阳光\"; } } Test public class Test { public static void main(String[] args) { Context ctx1 = new Context(); ctx1.setWeather(new Sunshine()); System.out.println(ctx1.weatherMessage()); System.out.println(\"=================\"); Context ctx2 = new Context(); ctx2.setWeather(new Rain()); System.out.println(ctx2.weatherMessage()); } } 运行结果： 阳光 ================= 下雨 ","date":"2019-08-29","objectID":"/state-pattern/:4:0","tags":["pattern"],"title":"行为型模式-状态模式","uri":"/state-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-27","objectID":"/observer-pattern/:0:0","tags":["pattern"],"title":"行为型模式-观察者模式","uri":"/observer-pattern/"},{"categories":["设计模式"],"content":"观察者模式 观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。 ","date":"2019-08-27","objectID":"/observer-pattern/:1:0","tags":["pattern"],"title":"行为型模式-观察者模式","uri":"/observer-pattern/"},{"categories":["设计模式"],"content":"参与类别 参与本模式的各类别列出如下。成员函式以模拟的方式列出。 抽象目标类别 此抽象类别提供一个界面让观察者进行添附与解附作业。此类别内有个不公开的观察者串炼，并透过下列函式(方法)进行作业 添附(Attach)：新增观察者到串炼内，以追踪目标对象的变化。 解附(Detach)：将已经存在的观察者从串炼中移除。 通知(Notify)：利用观察者所提供的更新函式来通知此目标已经产生变化。 添附函式包涵了一个观察者对象参数。也许是观察者类别的虚拟函式(即更新函式)，或是在非面向对象的设定中所使用的函式指标(更广泛来讲，函式子或是函式对象)。 目标类别 此类别提供了观察者欲追踪的状态。也利用其源类别(例如前述的抽象目标类别)所提供的方法,来通知所有的观察者其状态已经更新。此类别拥有以下函式 取得状态(GetState)：回传该目标对象的状态。 抽象观察者界面 抽象观察者类别是一个必须被实做的抽象类别。这个类别定义了所有观察者都拥有的更新用界面，此界面是用来接收目标类别所发出的更新通知。此类别含有以下函式 更新(Update)：会被实做的一个抽象(虚拟)函式。 观察者类别 这个类别含有指向目标类别的参考(reference)，以接收来自目标类别的更新状态。此类别含有以下函式 更新(Update)：是前述抽象函式的实做。当这个函式被目标对象呼叫时，观察者对象将会呼叫目标对象的取得状态函式，来其所拥有的更新目标对象资讯。 每个观察者类别都要实做它自己的更新函式，以应对状态更新的情形。 当目标对象改变时，会通过呼叫它自己的通知函式来将通知送给每一个观察者对象，这个通知函式则会去呼叫已经添附在串炼内的观察者更新函式。通知与更新函式可能会有一些参数，好指明是目前目标对象内的何种改变。这么作将可增进观察者的效率(只更新那些改变部分的状态)。 ","date":"2019-08-27","objectID":"/observer-pattern/:2:0","tags":["pattern"],"title":"行为型模式-观察者模式","uri":"/observer-pattern/"},{"categories":["设计模式"],"content":"用途 当抽象个体有两个互相依赖的层面时。封装这些层面在单独的对象内将可允许程序员单独地去变更与重复使用这些对象，而不会产生两者之间交互的问题。 当其中一个对象的变更会影响其他对象，却又不知道多少对象必须被同时变更时。 当对象应该有能力通知其他对象，又不应该知道其他对象的实做细节时。 观察者模式通常与 MVC 范式有关系。在 MVC 中，观察者模式被用来降低 model 与 view 的耦合程度。一般而言， model 的改变会触发通知其他身为观察者的 model 。而这些 model 实际上是 view 。 Java Swing 就是个范例，示意了 model 预期会透过 PropertyChangeNotification 架构以送出改变的通知给其他 view 。 Model 类别是 Java bean 类别的一员，并拥有与上述目标类别同样的行为。 View 类别则系结了一些 GUI 中的可视元素，并拥有与上述观察者类别同样的行为。当应用程序在执行时。使用者将因 view 做出相应的更新而看见 model 所产生的变更。 例子 Subject（目标） 目标知道它的观察者。可以有任意多个观察者观察同一个目标。 提供注册和删除观察者对象的接口。 import java.util.ArrayList; import java.util.List; public abstract class Citizen { List pols; private String help = \"normal\"; public String getHelp() { return help; } public void setHelp(String help) { this.help = help; } abstract void sendMessage(String help); public void setPoliceman(){ this.pols = new ArrayList(); } public void register(Policeman pol){ this.pols.add(pol); } public void unRegister(Policeman pol){ this.pols.remove(pol); } } Observer（观察者） 为那些在目标发生改变时需获得通知的对象定义一个更新接口。 public interface Policeman { void action(Citizen ci); } ConcreteSubject（具体目标） 将有关状态存入各ConcreteObserver对象。 当它的状态发生改变时,向它的各个观察者发出通知。 public class HuangPuCitizen extends Citizen { public HuangPuCitizen(Policeman pol){ setPoliceman(); register(pol); } @Override void sendMessage(String help) { setHelp(help); for(int i=0;i\u003cpols.size();i++){ Policeman pol = (Policeman) pols.get(i); //通知警察行动 pol.action(this); } } } public class TianHeCitizen extends Citizen { public TianHeCitizen(Policeman pol){ setPoliceman(); register(pol); } @Override void sendMessage(String help) { setHelp(help); for(int i=0;i\u003cpols.size();i++){ Policeman pol = (Policeman) pols.get(i); //通知警察行动 pol.action(this); } } } ConcreteObserver（具体观察者） 维护一个指向ConcreteSubject对象的引用。 存储有关状态，这些状态应与目标的状态保持一致。 实现Observer的更新接口并使自身状态与目标的状态保持一致 public class HuangPuPoliceman implements Policeman { @Override public void action(Citizen ci) { String help = ci.getHelp(); if (help.equals(\"normal\")){ System.out.println(\"一切正常，不用出动\"); } if(help.equals(\"unnormal\")){ System.out.println(\"有犯罪行为，黄埔警察出动\"); } } } public class TianHePoliceman implements Policeman { @Override public void action(Citizen ci) { String help = ci.getHelp(); if (help.equals(\"normal\")){ System.out.println(\"一切正常，不用出动\"); } if(help.equals(\"unnormal\")){ System.out.println(\"有犯罪行为，天河警察出动\"); } } } Test public class Test { public static void main(String[] args) { Policeman hpPol = new HuangPuPoliceman(); Policeman thPol = new TianHePoliceman(); Citizen citizen = new HuangPuCitizen(hpPol); citizen.sendMessage(\"unnormal\"); citizen.sendMessage(\"normal\"); System.out.println(\"======================\"); Citizen citizen1 = new TianHeCitizen(thPol); citizen1.sendMessage(\"normal\"); citizen1.sendMessage(\"unnormal\"); } } 运行结果： 有犯罪行为，黄埔警察出动 一切正常，不用出动 ====================== 一切正常，不用出动 有犯罪行为，天河警察出动 ","date":"2019-08-27","objectID":"/observer-pattern/:3:0","tags":["pattern"],"title":"行为型模式-观察者模式","uri":"/observer-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-26","objectID":"/mediator-pattern/:0:0","tags":["pattern"],"title":"行为型模式-中介者模式","uri":"/mediator-pattern/"},{"categories":["设计模式"],"content":"中介者模式 在软件工程领域，中介者模式定义了一个中介者对象，该对象封装了系统中对象间的交互方式。 由于它可以在运行时改变程序的行为，这种模式是一种行为型模式 。 通常程序由大量的类组成，这些类中包含程序的逻辑和运算。 然而，当开发者将更多的类加入到程序中之后，类间交互关系可能变得更为复杂，这会使得代码变得更加难以阅读和维护，尤其是在重构的时候。 此外，程序将会变得难以修改，因为对其所做的任何修改都有可能影响到其它几个类中的代码。 在中介者模式中，对象间的通信过程被封装在一个中介者（调解人）对象之中。 对象之间不再直接交互，而是通过调解人进行交互。 这么做可以减少可交互对象间的依赖，从而降低耦合。 ","date":"2019-08-26","objectID":"/mediator-pattern/:1:0","tags":["pattern"],"title":"行为型模式-中介者模式","uri":"/mediator-pattern/"},{"categories":["设计模式"],"content":"概述 中介者模式是23个周知模式（ 即GoF设计模式）中的一个，GoF设计模式旨在提供重复出现的设计问题的解决方案，以编写灵活和可复用的面向对象软件。也就是说，使对象更加易于实现、修改、测试和复用。 中介者设计模式可以解决什么问题？ 避免一组相互交互的对象之间出现紧耦合。 能够独立地改变一组对象之间的交互关系而不影响其他对象。 使用直接逐个访问并更新彼此的方式进行对象间的交互灵活性低，因为这种方式使对象彼此间紧密耦合，导致不可能单独修改类间交互关系本身，而不影响关系中进行交互的类。并且这种方式会令对象变得无法复用，并且难以测试。 由于紧耦合的对象过多了解其他对象的内部细节，这种对象难以实现、修改、测试以及复用。 中介者模式如何解决上述问题？ 定义一个独立的中介者(调解员)的对象，封装一组对象之间的交互关系。 对象将自己的交互委托给中介者执行，避免直接与其他对象进行交互。 对象利用中介者对象与其他对象进行间接交互，中介者对象负责控制和协调交互关系，这么做可使得对象间松耦合。这些对象只访问中介者，不了解其他对象的细节。 ","date":"2019-08-26","objectID":"/mediator-pattern/:2:0","tags":["pattern"],"title":"行为型模式-中介者模式","uri":"/mediator-pattern/"},{"categories":["设计模式"],"content":"定义 中介者模式是为了“定义一个封装了对象间交互关系的对象”。这种方式避免了显式调用其他类，促进了类间的松耦合，并且使得类间交互关系本身可以单独修改。客户类可以使用中介者向其他客户类发送信息，并且通过中介者引发的事件收到信息。 ","date":"2019-08-26","objectID":"/mediator-pattern/:3:0","tags":["pattern"],"title":"行为型模式-中介者模式","uri":"/mediator-pattern/"},{"categories":["设计模式"],"content":"Java 在以下示例中，一个中介者对象控制了三个互相交互的按钮的状态，为此它有设置状态的三个方法：book(), view() 和 search()。 当相应的按钮被激活时，对应的方法通过execute()方法被调用。 于是这里在交互中每个交互的参与者（本例中即按钮）将自己的行为提交给中介者并且由中介者将这些行为转给对应的参与者。 import java.awt.Font; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; //Colleague interface interface Command { void execute(); } //Abstract Mediator interface Mediator { void book(); void view(); void search(); void registerView(BtnView v); void registerSearch(BtnSearch s); void registerBook(BtnBook b); void registerDisplay(LblDisplay d); } //Concrete mediator class ParticipantMediator implements Mediator { BtnView btnView; BtnSearch btnSearch; BtnBook btnBook; LblDisplay show; //.... public void registerView(BtnView v) { btnView = v; } public void registerSearch(BtnSearch s) { btnSearch = s; } public void registerBook(BtnBook b) { btnBook = b; } public void registerDisplay(LblDisplay d) { show = d; } public void book() { btnBook.setEnabled(false); btnView.setEnabled(true); btnSearch.setEnabled(true); show.setText(\"booking...\"); } public void view() { btnView.setEnabled(false); btnSearch.setEnabled(true); btnBook.setEnabled(true); show.setText(\"viewing...\"); } public void search() { btnSearch.setEnabled(false); btnView.setEnabled(true); btnBook.setEnabled(true); show.setText(\"searching...\"); } } //A concrete colleague class BtnView extends JButton implements Command { Mediator med; BtnView(ActionListener al, Mediator m) { super(\"View\"); addActionListener(al); med = m; med.registerView(this); } public void execute() { med.view(); } } //A concrete colleague class BtnSearch extends JButton implements Command { Mediator med; BtnSearch(ActionListener al, Mediator m) { super(\"Search\"); addActionListener(al); med = m; med.registerSearch(this); } public void execute() { med.search(); } } //A concrete colleague class BtnBook extends JButton implements Command { Mediator med; BtnBook(ActionListener al, Mediator m) { super(\"Book\"); addActionListener(al); med = m; med.registerBook(this); } public void execute() { med.book(); } } class LblDisplay extends JLabel { Mediator med; LblDisplay(Mediator m) { super(\"Just start...\"); med = m; med.registerDisplay(this); setFont(new Font(\"Arial\", Font.BOLD, 24)); } } class MediatorDemo extends JFrame implements ActionListener { Mediator med = new ParticipantMediator(); MediatorDemo() { JPanel p = new JPanel(); p.add(new BtnView(this, med)); p.add(new BtnBook(this, med)); p.add(new BtnSearch(this, med)); getContentPane().add(new LblDisplay(med), \"North\"); getContentPane().add(p, \"South\"); setSize(400, 200); setVisible(true); } public void actionPerformed(ActionEvent ae) { Command comd = (Command) ae.getSource(); comd.execute(); } public static void main(String[] args) { new MediatorDemo(); } } 例子 Colleagueclass public class Colleague { public void action(){ } } public class ColleagueA extends Colleague{ @Override public void action() { System.out.println(\"普通员工努力工作\"); } } public class ColleagueB extends Colleague { @Override public void action() { System.out.println(\"前台注意了\"); } } Mediator public abstract class Mediator { public abstract void notice(String content); } ConcreteMediator public class ConcreateMedator extends Mediator { private ColleagueA ca; private ColleagueB cb; public ConcreateMedator() { ca=new ColleagueA(); cb=new ColleagueB(); } @Override public void notice(String content) { if(content.equals(\"boss\")){ ca.action(); } if(content.equals(\"client\")){ cb.action(); } } } Test public class Test { public static void main(String[] args) { Mediator med = new ConcreateMedator(); med.notice(\"boss\"); med.notice(\"client\"); } } 运行结果： 普通员工努力工作 前台注意了 ","date":"2019-08-26","objectID":"/mediator-pattern/:4:0","tags":["pattern"],"title":"行为型模式-中介者模式","uri":"/mediator-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-26","objectID":"/iterator-pattern/:0:0","tags":["pattern"],"title":"行为型模式-迭代器模式","uri":"/iterator-pattern/"},{"categories":["设计模式"],"content":"迭代器模式 在 面向对象编程里，迭代器模式是一种设计模式，是一种最简单也最常见的设计模式。它可以让用户透过特定的接口巡访容器中的每一个元素而不用了解底层的实现。 此外，也可以实现特定目的版本的迭代器。 ","date":"2019-08-26","objectID":"/iterator-pattern/:1:0","tags":["pattern"],"title":"行为型模式-迭代器模式","uri":"/iterator-pattern/"},{"categories":["设计模式"],"content":"接口 《设计模式》建议合理的接口该要有： public interface Iterator { public Object First(); public Object Next(); public boolean isDone(); public Object CurrentItem(); } ","date":"2019-08-26","objectID":"/iterator-pattern/:2:0","tags":["pattern"],"title":"行为型模式-迭代器模式","uri":"/iterator-pattern/"},{"categories":["设计模式"],"content":"Java interface Iterator{ Object First(); Object Next(); boolean IsDone(); Object CurrentItem(); } abstract class Aggregate{ abstract Iterator CreateIterator(); } class ConcreteIterator implements Iterator{ private List\u003cObject\u003e list = new ArrayList\u003cObject\u003e(); private int curr=0; public ConcreteIterator(List\u003cObject\u003e list){ this.list = list; } public Object First(){ return list.get(0); } public Object Next(){ Object ret = null; curr++; if(curr \u003c list.size()){ ret = list.get(curr); } return ret; } public boolean IsDone(){ return curr\u003e=list.size()?true:false; } public Object CurrentItem(){ return list.get(curr); } } class ConcreteAggregate extends Aggregate{ private List\u003cObject\u003e list = new ArrayList\u003cObject\u003e(); public ConcreteAggregate(List\u003cObject\u003e list){ this.list = list; } public Iterator CreateIterator(){ return new ConcreteIterator(list); } } class client{ public static void main(String[] args){ List\u003cObject\u003e list = new ArrayList\u003cObject\u003e(); list.add(\"miner\"); list.add(\"any\"); Aggregate agg = new ConcreteAggregate(list); Iterator iterator = agg.CreateIterator(); iterator.First(); while(!iterator.IsDone()){ System.out.println(iterator.CurrentItem()); iterator.Next(); } } } 例子 Aggregate 聚合定义创建相应迭代器对象的接口。 public interface List { Iterator iterator(); Object get(int index); int getSize(); void add(Object obj); } Iterator 迭代器定义访问和遍历元素的接口。 public interface Iterator { Object next(); void first(); void last(); boolean hasNext(); } ConcreteIterator 具有迭代器实现迭代器接口。 对该聚合遍历时跟踪当前位置。 public class IteratorImpl implements Iterator { private List list; private int index; public IteratorImpl(List list) { this.list = list; index=0; } @Override public Object next() { Object obj = list.get(index); index++; return obj; } @Override public void first() { index=0; } @Override public void last() { index=list.getSize(); } @Override public boolean hasNext() { return index\u003clist.getSize(); } } ConcreteAggregate 具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例 public class ListImpl implements List { private Object[] list; private int index; private int size; public ListImpl() { index=0; size=0; list = new Object[100]; } @Override public Iterator iterator() { return new IteratorImpl(this); } @Override public Object get(int index) { return list[index]; } @Override public int getSize() { return this.size; } @Override public void add(Object obj) { list[index++]=obj; size++; } } Test public class Test { public static void main(String[] args) { List list = new ListImpl(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); //第一种迭代方式 Iterator it = list.iterator(); while (it.hasNext()){ System.out.println(it.next()); } System.out.println(\"=============\"); //第二种迭代方式 for(int i=0;i\u003clist.getSize();i++){ System.out.println(list.get(i)); } } } 运行结果： a b c ============= a b c ","date":"2019-08-26","objectID":"/iterator-pattern/:3:0","tags":["pattern"],"title":"行为型模式-迭代器模式","uri":"/iterator-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-26","objectID":"/command-pattern/:0:0","tags":["pattern"],"title":"行为型模式-命令模式","uri":"/command-pattern/"},{"categories":["设计模式"],"content":"命令模式 在面向对象编程的范畴中，命令模式（英语：Command pattern）是一种设计模式，它尝试以对象来代表实际行动。命令对象可以把行动(action) 及其参数封装起来，于是这些行动可以被： 重复多次 取消（如果该对象有实现的话） 取消后又再重做 这些都是现代大型应用程序所必须的功能，即“撤销”及“重复”。除此之外，可以用命令模式来实现的功能例子还有： 交易行为 进度列 向导 用户界面按钮及功能表项目 线程 pool 宏收录 ","date":"2019-08-26","objectID":"/command-pattern/:1:0","tags":["pattern"],"title":"行为型模式-命令模式","uri":"/command-pattern/"},{"categories":["设计模式"],"content":"Java import java.util.List; import java.util.ArrayList; /* The Command interface */ public interface Command { void execute(); } /* The Invoker class */ public class Switch { private List\u003cCommand\u003e history = new ArrayList\u003cCommand\u003e(); public Switch() { } public void storeAndExecute(Command cmd) { this.history.add(cmd); // optional cmd.execute(); } } /* The Receiver class */ public class Light { public Light() { } public void turnOn() { System.out.println(\"The light is on\"); } public void turnOff() { System.out.println(\"The light is off\"); } } /* The Command for turning on the light - ConcreteCommand #1 */ public class FlipUpCommand implements Command { private Light theLight; public FlipUpCommand(Light light) { this.theLight = light; } public void execute(){ theLight.turnOn(); } } /* The Command for turning off the light - ConcreteCommand #2 */ public class FlipDownCommand implements Command { private Light theLight; public FlipDownCommand(Light light) { this.theLight = light; } public void execute() { theLight.turnOff(); } } /* The test class or client */ public class PressSwitch { public static void main(String[] args){ Light lamp = new Light(); Command switchUp = new FlipUpCommand(lamp); Command switchDown = new FlipDownCommand(lamp); Switch mySwitch = new Switch(); try { if (\"ON\".equalsIgnoreCase(args[0])) { mySwitch.storeAndExecute(switchUp); } else if (\"OFF\".equalsIgnoreCase(args[0])) { mySwitch.storeAndExecute(switchDown); } else { System.out.println(\"Argument \\\"ON\\\" or \\\"OFF\\\" is required.\"); } } catch (Exception e) { System.out.println(\"Arguments required.\"); } } } 例子 Receiver 知道如何实现与执行一个请求相关的操作。任何类都可能作为一个接收者。 public class Receiver { public void receive(){ System.out.println(\"This is Receive class!\"); } } Command 声明执行操作的接口。 public abstract class Command { protected Receiver receiver; public Command(Receiver receiver) { this.receiver = receiver; } public abstract void execute(); } ConcreteCommand 将一个接收者对象绑定于一个动作。 调用接收者相应的操作，以实现Execute。 public class CommandImpl extends Command { public CommandImpl(Receiver receiver) { super(receiver); } @Override public void execute() { receiver.receive(); } } Invoker 要求该命令执行这个请求。 public class Invoker { private Command command; public void setCommand(Command command) { this.command = command; } public void execute(){ command.execute(); } } Client 创建一个具体命令对象并设定它的接收者。 public class Test { public static void main(String[] args) { Receiver rec = new Receiver(); Command cmd = new CommandImpl(rec); Invoker i = new Invoker(); i.setCommand(cmd); i.execute(); } } 运行结果： This is Receive class! ","date":"2019-08-26","objectID":"/command-pattern/:2:0","tags":["pattern"],"title":"行为型模式-命令模式","uri":"/command-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-26","objectID":"/responsibility-chain-pattern/:0:0","tags":["pattern"],"title":"行为型模式-责任链模式","uri":"/responsibility-chain-pattern/"},{"categories":["设计模式"],"content":"责任链模式 责任链模式在面向对象程式设计里是一种软件设计模式，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。 ","date":"2019-08-26","objectID":"/responsibility-chain-pattern/:1:0","tags":["pattern"],"title":"行为型模式-责任链模式","uri":"/responsibility-chain-pattern/"},{"categories":["设计模式"],"content":"Java 以下的日志类(logging)例子演示了该模式。 每一个logging handler首先决定是否需要在该层做处理，然后将控制传递到下一个logging handler。程序的输出是: Writing to debug output: Entering function y. Writing to debug output: Step1 completed. Sending via e-mail: Step1 completed. Writing to debug output: An error has occurred. Sending via e-mail: An error has occurred. Writing to stderr: An error has occurred. 注意：该例子不是日志类的推荐实现方式。 同时，需要注意的是，通常在责任链模式的实现中，如果在某一层已经处理了这个logger，那么这个logger就不会传递下去。在我们这个例子中，消息会一直传递到最底层不管它是否已经被处理。 abstract class Logger { public static int ERR = 3; public static int NOTICE = 5; public static int DEBUG = 7; protected int mask; // The next element in the chain of responsibility protected Logger next; public Logger setNext( Logger l) { next = l; return this; } public final void message( String msg, int priority ) { if ( priority \u003c= mask ) { writeMessage( msg ); if ( next != null ) { next.message( msg, priority ); } } } protected abstract void writeMessage( String msg ); } class StdoutLogger extends Logger { public StdoutLogger( int mask ) { this.mask = mask; } protected void writeMessage( String msg ) { System.out.println( \"Writting to stdout: \" + msg ); } } class EmailLogger extends Logger { public EmailLogger( int mask ) { this.mask = mask; } protected void writeMessage( String msg ) { System.out.println( \"Sending via email: \" + msg ); } } class StderrLogger extends Logger { public StderrLogger( int mask ) { this.mask = mask; } protected void writeMessage( String msg ) { System.out.println( \"Sending to stderr: \" + msg ); } } public class ChainOfResponsibilityExample { public static void main( String[] args ) { // Build the chain of responsibility Logger l = new StdoutLogger( Logger.DEBUG).setNext( new EmailLogger( Logger.NOTICE ).setNext( new StderrLogger( Logger.ERR ) ) ); // Handled by StdoutLogger l.message( \"Entering function y.\", Logger.DEBUG ); // Handled by StdoutLogger and EmailLogger l.message( \"Step1 completed.\", Logger.NOTICE ); // Handled by all three loggers l.message( \"An error has occurred.\", Logger.ERR ); } } 例子 public interface Request { } public class DimissionRequest implements Request { } public class AddMoneyRequest implements Request { } public class LeaveRequest implements Request { } Handler public interface RequestHandle { void handleRequest(Request request); } ConcreteHandler public class HRRequestHandle implements RequestHandle { @Override public void handleRequest(Request request) { if (request instanceof DimissionRequest){ System.out.println(\"要离职，人事审批!\"); } System.out.println(\"请求完毕\"); } } public class PMRequestHandle implements RequestHandle { RequestHandle rh; public PMRequestHandle(RequestHandle rh) { this.rh = rh; } @Override public void handleRequest(Request request) { if(request instanceof AddMoneyRequest){ System.out.println(\"要加薪，项目经理审批!\"); }else { rh.handleRequest(request); } } } public class TLRequestHandle implements RequestHandle { RequestHandle rh; public TLRequestHandle(RequestHandle rh) { this.rh = rh; } @Override public void handleRequest(Request request) { if(request instanceof LeaveRequest){ System.out.println(\"要请假，项目组长审批!\"); }else { rh.handleRequest(request); } } } Client public class Test { public static void main(String[] args) { RequestHandle hr = new HRRequestHandle(); RequestHandle pm = new PMRequestHandle(hr); RequestHandle tl = new TLRequestHandle(pm); //处理离职请求 Request request = new DimissionRequest(); tl.handleRequest(request); System.out.println(\"=================\"); //处理加薪请求 request = new AddMoneyRequest(); tl.handleRequest(request); System.out.println(\"==================\"); //处理请假请求 request = new LeaveRequest(); tl.handleRequest(request); } } 运行结果： 要离职，人事审批! 请求完毕 ================= 要加薪，项目经理审批! ================== 要请假，项目组长审批! ","date":"2019-08-26","objectID":"/responsibility-chain-pattern/:2:0","tags":["pattern"],"title":"行为型模式-责任链模式","uri":"/responsibility-chain-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-25","objectID":"/proxy-pattern/:0:0","tags":["pattern"],"title":"结构型模式-代理模式","uri":"/proxy-pattern/"},{"categories":["设计模式"],"content":"代理模式 代理模式（英语：Proxy Pattern）是程序设计中的一种设计模式。 所谓的代理者是指一个类别可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、存储器中的大对象、文件或其它昂贵或无法复制的资源。 著名的代理模式例子为引用计数（英语：reference counting）指针对象。 当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少存储器用量。典型作法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。 ","date":"2019-08-25","objectID":"/proxy-pattern/:1:0","tags":["pattern"],"title":"结构型模式-代理模式","uri":"/proxy-pattern/"},{"categories":["设计模式"],"content":"Java 以下Java示例解释\"虚拟代理\"模式。ProxyImage 类别用来访问远程方法。 import java.util.*; interface Image { public void displayImage(); } //on System A class RealImage implements Image { private String filename; public RealImage(String filename) { this.filename = filename; loadImageFromDisk(); } private void loadImageFromDisk() { System.out.println(\"Loading \" + filename); } public void displayImage() { System.out.println(\"Displaying \" + filename); } } //on System B class ProxyImage implements Image { private String filename; private Image image; public ProxyImage(String filename) { this.filename = filename; } public void displayImage() { if(image == null) image = new RealImage(filename); image.displayImage(); } } class ProxyExample { public static void main(String[] args) { Image image1 = new ProxyImage(\"HiRes_10MB_Photo1\"); Image image2 = new ProxyImage(\"HiRes_10MB_Photo2\"); image1.displayImage(); // loading necessary image2.displayImage(); // loading necessary } } 程序的输出为： Loading HiRes_10MB_Photo1 Displaying HiRes_10MB_Photo1 Loading HiRes_10MB_Photo2 Displaying HiRes_10MB_Photo2 例子 接口 public interface Object { void action(); } 接口的实现类 public class ObjectImpl implements Object { @Override public void action() { System.out.println(\"===========\"); System.out.println(\"这是被代理的类\"); System.out.println(\"===========\"); } } 代理类 public class ProxyObject implements Object{ Object obj; public ProxyObject(){ System.out.println(\"这是代理类\"); obj = new ObjectImpl(); } @Override public void action() { System.out.println(\"代理开始\"); obj.action(); System.out.println(\"代理结束\"); } } Test public class Test { public static void main(String[] args) { Object obj = new ProxyObject(); obj.action(); } } 运行结果： 这是代理类 代理开始 =========== 这是被代理的类 =========== 代理结束 ","date":"2019-08-25","objectID":"/proxy-pattern/:2:0","tags":["pattern"],"title":"结构型模式-代理模式","uri":"/proxy-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-25","objectID":"/flyweight-pattern/:0:0","tags":["pattern"],"title":"结构型模式-享元模式","uri":"/flyweight-pattern/"},{"categories":["设计模式"],"content":"享元模式 享元模式（英语：Flyweight Pattern）是一种软件设计模式。它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。 典型的享元模式的例子为文书处理器中以图形结构来表示字符。一个做法是，每个字形有其字型外观, 字模 metrics, 和其它格式资讯，但这会使每个字符就耗用上千字节。取而代之的是，每个字符参照到一个共享字形物件，此物件会被其它有共同特质的字符所分享；只有每个字符（文件中或页面中）的位置才需要另外储存。 ","date":"2019-08-25","objectID":"/flyweight-pattern/:1:0","tags":["pattern"],"title":"结构型模式-享元模式","uri":"/flyweight-pattern/"},{"categories":["设计模式"],"content":"Java 以下程式用来解释上述的文字。这个例子用来解释享元模式利用只加载执行任务时所必需的最少资料，因而减少内存使用量。 public enum FontEffect { BOLD, ITALIC, SUPERSCRIPT, SUBSCRIPT, STRIKETHROUGH } public final class FontData { /** * A weak hash map will drop unused references to FontData. * Values have to be wrapped in WeakReferences, * because value objects in weak hash map are held by strong references. */ private static final WeakHashMap\u003cFontData, WeakReference\u003cFontData\u003e\u003e FLY_WEIGHT_DATA = new WeakHashMap\u003cFontData, WeakReference\u003cFontData\u003e\u003e(); private final int pointSize; private final String fontFace; private final Color color; private final Set\u003cFontEffect\u003e effects; private FontData(int pointSize, String fontFace, Color color, EnumSet\u003cFontEffect\u003e effects) { this.pointSize = pointSize; this.fontFace = fontFace; this.color = color; this.effects = Collections.unmodifiableSet(effects); } public static FontData create(int pointSize, String fontFace, Color color, FontEffect... effects) { EnumSet\u003cFontEffect\u003e effectsSet = EnumSet.noneOf(FontEffect.class); for (FontEffect fontEffect : effects) { effectsSet.add(fontEffect); } // We are unconcerned with object creation cost, we are reducing overall memory consumption FontData data = new FontData(pointSize, fontFace, color, effectsSet); // Retrieve previously created instance with the given values if it (still) exists WeakReference\u003cFontData\u003e ref = FLY_WEIGHT_DATA.get(data); FontData result = (ref != null) ? ref.get() : null; // Store new font data instance if no matching instance exists if (result == null) { FLY_WEIGHT_DATA.put(data, new WeakReference\u003cFontData\u003e (data)); result = data; } // return the single immutable copy with the given values return result; } @Override public boolean equals(Object obj) { if (obj instanceof FontData) { if (obj == this) { return true; } FontData other = (FontData) obj; return other.pointSize == pointSize \u0026\u0026 other.fontFace.equals(fontFace) \u0026\u0026 other.color.equals(color) \u0026\u0026 other.effects.equals(effects); } return false; } @Override public int hashCode() { return (pointSize * 37 + effects.hashCode() * 13) * fontFace.hashCode(); } // Getters for the font data, but no setters. FontData is immutable. } 例子 Flyweight public interface Flyweight { void action(int arg); } ConcreteFlyweight public class FlyweightImpl implements Flyweight { @Override public void action(int arg) { System.out.println(\"参数值：\"+arg); } } FlyweightFactory import java.util.HashMap; import java.util.Map; public class FlyweightFactory { private static Map flyweights = new HashMap(); public FlyweightFactory(String arg){ flyweights.put(arg,new FlyweightImpl()); } public static Flyweight getFlyweight(String key){ if(flyweights.get(key)==null){ flyweights.put(key,new FlyweightImpl()); } return (Flyweight) flyweights.get(key); } public static int getSize(){ return flyweights.size(); } } Test public class Test { public static void main(String[] args) { Flyweight fly1 = FlyweightFactory.getFlyweight(\"a\"); fly1.action(1); Flyweight fly2 = FlyweightFactory.getFlyweight(\"a\"); System.out.println(fly1==fly2); Flyweight fly3 = FlyweightFactory.getFlyweight(\"b\"); fly3.action(2); Flyweight fly4 = FlyweightFactory.getFlyweight(\"c\"); fly4.action(3); Flyweight fly5 = FlyweightFactory.getFlyweight(\"d\"); fly5.action(4); System.out.println(FlyweightFactory.getSize()); } } 运行结果： 参数值：1 true 参数值：2 参数值：3 参数值：4 4 ","date":"2019-08-25","objectID":"/flyweight-pattern/:2:0","tags":["pattern"],"title":"结构型模式-享元模式","uri":"/flyweight-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-25","objectID":"/facade-pattern/:0:0","tags":["pattern"],"title":"结构型模式-外观模式","uri":"/facade-pattern/"},{"categories":["设计模式"],"content":"外观模式 外观模式（Facade pattern），是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。 ","date":"2019-08-25","objectID":"/facade-pattern/:1:0","tags":["pattern"],"title":"结构型模式-外观模式","uri":"/facade-pattern/"},{"categories":["设计模式"],"content":"Java 这是一个抽象的示例。一个客户“you”通过外观接口“computer”获取计算机内部复杂的系统信息。 /* Complex parts */ class CPU { public void freeze() { ... } public void jump(long position) { ... } public void execute() { ... } } class Memory { public void load(long position, byte[] data) { ... } } class HardDrive { public byte[] read(long lba, int size) { ... } } /* Façade */ class Computer { public void startComputer() { cpu.freeze(); memory.load(BOOT_ADDRESS, hardDrive.read(BOOT_SECTOR, SECTOR_SIZE)); cpu.jump(BOOT_ADDRESS); cpu.execute(); } } /* Client */ class You { public static void main(String[] args) { Computer facade = new Computer(); facade.startComputer(); } } 例子 抽象类 public interface ServiceA { public void methodA(); } public interface ServiceB { public void methodB(); } public interface ServiceC { public void methodC(); } 实现类 public class ServiceAImpl implements ServiceA { @Override public void methodA() { System.out.println(\"这是服务A\"); } } public class ServiceBImpl implements ServiceB { @Override public void methodB() { System.out.println(\"这是服务B\"); } } public class ServiceCImpl implements ServiceC { @Override public void methodC() { System.out.println(\"这是服务C\"); } } 外观类 public class Facade { ServiceA sa; ServiceB sb; ServiceC sc; public Facade() { sa = new ServiceAImpl(); sb = new ServiceBImpl(); sc = new ServiceCImpl(); } public void methodA(){ sa.methodA(); sb.methodB(); } public void methodB(){ sb.methodB(); sc.methodC(); } public void methodC(){ sc.methodC(); sa.methodA(); } } Test public class Test { public static void main(String[] args) { ServiceA sa = new ServiceAImpl(); ServiceB sb = new ServiceBImpl(); sa.methodA(); sb.methodB(); System.out.println(\"=========\"); //facade Facade facade = new Facade(); facade.methodA(); facade.methodB(); } } 运行结果： 这是服务A 这是服务B ========= 这是服务A 这是服务B 这是服务B 这是服务C ","date":"2019-08-25","objectID":"/facade-pattern/:2:0","tags":["pattern"],"title":"结构型模式-外观模式","uri":"/facade-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-25","objectID":"/decorator-pattern/:0:0","tags":["pattern"],"title":"结构型模式-装饰模式","uri":"/decorator-pattern/"},{"categories":["设计模式"],"content":"修饰模式 修饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。 ","date":"2019-08-25","objectID":"/decorator-pattern/:1:0","tags":["pattern"],"title":"结构型模式-装饰模式","uri":"/decorator-pattern/"},{"categories":["设计模式"],"content":"介绍 通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。 修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。 当有几个相互独立的功能需要扩充时，这个区别就变得很重要。在有些面向对象的编程语言中，类不能在运行时被创建，通常在设计的时候也不能预测到有哪几种功能组合。这就意味着要为每一种组合创建一个新类。相反，修饰模式是面向运行时候的对象实例的,这样就可以在运行时根据需要进行组合。一个修饰模式的示例是JAVA里的Java I/O Streams的实现。 ","date":"2019-08-25","objectID":"/decorator-pattern/:2:0","tags":["pattern"],"title":"结构型模式-装饰模式","uri":"/decorator-pattern/"},{"categories":["设计模式"],"content":"动机 例如，一个窗口系统中的窗口，允许这个窗口内容滚动，我们希望给它添加水平或垂直滚动条。假设窗口通过“Window”类实例来表示，并且假设它没有添加滚动条功能。我们可以创建一个子类“ScrollingWindow”来提供，或者我们可以创建一个ScrollingWindowDecorator来为已存在的Window对象添加这个功能。在这点上，只要是解决方案就可以了。 现在我们假设希望选择给我们的窗口添加边框，同样，我们的原始Window类不支持。ScrollingWindow子类现在会造成一个问题，因为它会有效的创建一种新的窗口。如果我们想要给所有窗口添加边框，我们必须创建WindowWithBorder和ScrollingWindowWithBorder子类。显然，这个问题由于被添加类而变得更糟了。对于修饰模式，我们简单的创建一个新类BorderedWindowDecorator，在运行时，我们能够使用ScrollingWindowDecorator或BorderedWindowDecorator或两者结合来修饰已存在的窗口。 一个修饰能够被应用的另一个好例子是当有需要根据某套规则或者几个平行的规则集（不同的用户凭据等）限制访问对象的属性或方法时。 一个对象的属性或方法按照某组规则或几个并行规则(不同用户证书等)需要限制访问时，在这种情况下，不是在原始对象中实现访问控制而是在他的使用中不变或不知道任何限制，并且他被包装在一个访问控制修饰对象中，这个对象能够对允许的原始对象的接口子集服务。 ","date":"2019-08-25","objectID":"/decorator-pattern/:3:0","tags":["pattern"],"title":"结构型模式-装饰模式","uri":"/decorator-pattern/"},{"categories":["设计模式"],"content":"应用 Java IO 流为典型的装饰模式。 ","date":"2019-08-25","objectID":"/decorator-pattern/:4:0","tags":["pattern"],"title":"结构型模式-装饰模式","uri":"/decorator-pattern/"},{"categories":["设计模式"],"content":"Java 这个JAVA示例使用window/scrolling情境。 // The Window interface class public interface Window { public void draw(); // Draws the Window public String getDescription(); // Returns a description of the Window } // implementation of a simple Window without any scrollbars public class SimpleWindow implements Window { public void draw() { // Draw window } public String getDescription() { return \"simple window\"; } } 以下类包含所有Window类的decorator，以及修饰类本身。 // abstract decorator class - note that it implements Window public abstract class WindowDecorator implements Window { protected Window decoratedWindow; // the Window being decorated public WindowDecorator (Window decoratedWindow) { this.decoratedWindow = decoratedWindow; } @Override public void draw() { decoratedWindow.draw(); } @Override public String getDescription() { return decoratedWindow.getDescription(); } } // The first concrete decorator which adds vertical scrollbar functionality public class VerticalScrollBar extends WindowDecorator { public VerticalScrollBar(Window windowToBeDecorated) { super(windowToBeDecorated); } @Override public void draw() { super.draw(); drawVerticalScrollBar(); } private void drawVerticalScrollBar() { // Draw the vertical scrollbar } @Override public String getDescription() { return super.getDescription() + \", including vertical scrollbars\"; } } // The second concrete decorator which adds horizontal scrollbar functionality public class HorizontalScrollBar extends WindowDecorator { public HorizontalScrollBar (Window windowToBeDecorated) { super(windowToBeDecorated); } @Override public void draw() { super.draw(); drawHorizontalScrollBar(); } private void drawHorizontalScrollBar() { // Draw the horizontal scrollbar } @Override public String getDescription() { return super.getDescription() + \", including horizontal scrollbars\"; } } 以下是一个测试程序，它创建了一个包含多重装饰的Window实例(如,包含了垂直的和水平的滚动条),然后输出它的描述： public class Main { // for print descriptions of the window subclasses static void printInfo(Window w) { System.out.println(\"description:\"+w.getDescription()); } public static void main(String[] args) { // original SimpleWindow SimpleWindow sw = new SimpleWindow(); printInfo(sw); // HorizontalScrollBar mixed Window HorizontalScrollBar hbw = new HorizontalScrollBar(sw); printInfo(hbw); // VerticalScrollBar mixed Window VerticalScrollBar vbw = new VerticalScrollBar(hbw); printInfo(vbw); } } 以下是SimpleWindow及添加了组件HorizontalScrollBar和VerticalScrollBar后的Window测试结果： description:simple window description:simple window, including horizontal scrollbars description:simple window, including horizontal scrollbars, including vertical scrollbars ","date":"2019-08-25","objectID":"/decorator-pattern/:5:0","tags":["pattern"],"title":"结构型模式-装饰模式","uri":"/decorator-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-24","objectID":"/bridge-pattern/:0:0","tags":["pattern"],"title":"结构型模式-桥接模式","uri":"/bridge-pattern/"},{"categories":["设计模式"],"content":"桥接模式 桥接模式是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。 ","date":"2019-08-24","objectID":"/bridge-pattern/:1:0","tags":["pattern"],"title":"结构型模式-桥接模式","uri":"/bridge-pattern/"},{"categories":["设计模式"],"content":"Java /** \"Implementor\" */ interface DrawingAPI { public void drawCircle(double x, double y, double radius); } /** \"ConcreteImplementor\" 1/2 */ class DrawingAPI1 implements DrawingAPI { public void drawCircle(double x, double y, double radius) { System.out.printf(\"API1.circle at %f:%f radius %f\\n\", x, y, radius); } } /** \"ConcreteImplementor\" 2/2 */ class DrawingAPI2 implements DrawingAPI { public void drawCircle(double x, double y, double radius) { System.out.printf(\"API2.circle at %f:%f radius %f\\n\", x, y, radius); } } /** \"Abstraction\" */ interface Shape { public void draw(); // low-level public void resizeByPercentage(double pct); // high-level } /** \"Refined Abstraction\" */ class CircleShape implements Shape { private double x, y, radius; private DrawingAPI drawingAPI; public CircleShape(double x, double y, double radius, DrawingAPI drawingAPI) { this.x = x; this.y = y; this.radius = radius; this.drawingAPI = drawingAPI; } // low-level i.e. Implementation specific public void draw() { drawingAPI.drawCircle(x, y, radius); } // high-level i.e. Abstraction specific public void resizeByPercentage(double pct) { radius *= pct; } } /** \"Client\" */ class BridgePattern { public static void main(String[] args) { Shape[] shapes = new Shape[2]; shapes[0] = new CircleShape(1, 2, 3, new DrawingAPI1()); shapes[1] = new CircleShape(5, 7, 11, new DrawingAPI2()); for (Shape shape : shapes) { shape.resizeByPercentage(2.5); shape.draw(); } } } 运行结果： API1.circle at 1.000000:2.000000 radius 7.500000 API2.circle at 5.000000:7.000000 radius 27.500000 ","date":"2019-08-24","objectID":"/bridge-pattern/:2:0","tags":["pattern"],"title":"结构型模式-桥接模式","uri":"/bridge-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-24","objectID":"/adapter-pattern/:0:0","tags":["pattern"],"title":"结构型模式-适配器模式","uri":"/adapter-pattern/"},{"categories":["设计模式"],"content":"适配器模式 在设计模式中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装(wrapper)。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类能在一起工作，做法是将类自己的接口包裹在一个已存在的类中。 ","date":"2019-08-24","objectID":"/adapter-pattern/:1:0","tags":["pattern"],"title":"结构型模式-适配器模式","uri":"/adapter-pattern/"},{"categories":["设计模式"],"content":"结构 有两种类型的适配器模式： 对象适配器模式 在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。 类适配器模式 这种适配器模式下，适配器继承自已实现的类（一般多重继承）。 例子 Target 定义Client使用的与特定领域相关的接口。 public interface Target { void adapteeMethod(); void adapterMethod(); } Adaptee 定义一个已经存在的接口，这个接口需要适配。 public class Adaptee { public void adapteeMethod(){ System.out.println(\"Adaptee method\"); } } Adapter 对Adaptee的接口与Target接口进行适配 public class Adapter implements Target{ private Adaptee adaptee; public Adapter(Adaptee adaptee){ this.adaptee=adaptee; } @Override public void adapteeMethod() { adaptee.adapteeMethod(); } @Override public void adapterMethod() { System.out.println(\"Adapter method\"); } } Client 与符合Target接口的对象协同。 public class Test { public static void main(String[] args) { Target target = new Adapter(new Adaptee()); target.adapteeMethod(); target.adapterMethod(); } } 运行结果： Adaptee method Adapter method ","date":"2019-08-24","objectID":"/adapter-pattern/:2:0","tags":["pattern"],"title":"结构型模式-适配器模式","uri":"/adapter-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-24","objectID":"/prototype/:0:0","tags":["pattern"],"title":"创建型模式-原型模式","uri":"/prototype/"},{"categories":["设计模式"],"content":"原型模式 原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。 原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。 ","date":"2019-08-24","objectID":"/prototype/:1:0","tags":["pattern"],"title":"创建型模式-原型模式","uri":"/prototype/"},{"categories":["设计模式"],"content":"Java /** Prototype Class **/ public class Cookie implements Cloneable { public Object clone() throws CloneNotSupportedException { //In an actual implementation of this pattern you would now attach references to //the expensive to produce parts from the copies that are held inside the prototype. return (Cookie) super.clone(); } } /** Concrete Prototypes to clone **/ public class CoconutCookie extends Cookie { } /** Client Class**/ public class CookieMachine { private Cookie cookie;//cookie必须是可复制的 public CookieMachine(Cookie cookie) { this.cookie = cookie; } public Cookie makeCookie() { try { return (Cookie) cookie.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return null; } public static void main(String args[]){ Cookie tempCookie = null; Cookie prot = new CoconutCookie(); CookieMachine cm = new CookieMachine(prot); //设置原型 for(int i=0; i\u003c100; i++) tempCookie = cm.makeCookie();//通过复制原型返回多个cookie } } 例子 Prototype 声明一个克隆自身的接口 public class Prototype implements Cloneable{ private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); return null; } } } ConcretePrototype 实现一个克隆自身的操作。 public class ConcreatePrototype extends Prototype { public ConcreatePrototype(String name){ setName(name); } } Client 让一个原型克隆自身从而创建一个新的对象。 public class Test { public static void main(String[] args) { Prototype pro = new ConcreatePrototype(\"prototype\"); Prototype pro2 = (Prototype) pro.clone(); System.out.println(pro.getName()); System.out.println(pro2.getName()); System.out.println(pro); System.out.println(pro2); } } 运行结果： prototype prototype ConcreatePrototype@677327b6 ConcreatePrototype@14ae5a5 ","date":"2019-08-24","objectID":"/prototype/:2:0","tags":["pattern"],"title":"创建型模式-原型模式","uri":"/prototype/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-23","objectID":"/single-case-pattern/:0:0","tags":["pattern"],"title":"创建型模式-单例模式","uri":"/single-case-pattern/"},{"categories":["设计模式"],"content":"单例模式 单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。 单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。 ","date":"2019-08-23","objectID":"/single-case-pattern/:1:0","tags":["pattern"],"title":"创建型模式-单例模式","uri":"/single-case-pattern/"},{"categories":["设计模式"],"content":"构建方式 通常单例模式在Java语言中，有两种构建方式： 懒汉方式。指全局的单例实例在第一次被使用时构建。 饿汉方式。指全局的单例实例在类装载时构建。 ","date":"2019-08-23","objectID":"/single-case-pattern/:2:0","tags":["pattern"],"title":"创建型模式-单例模式","uri":"/single-case-pattern/"},{"categories":["设计模式"],"content":"Java 在Java语言中，单例模式(饿汉模式)应用的例子如下述代码所示： public class Singleton { private static final Singleton INSTANCE = new Singleton(); // Private constructor suppresses // default public constructor private Singleton() {}; public static Singleton getInstance() { return INSTANCE; } } 在Java编程语言中，单例模式(懒汉模式)应用的例子如下述代码所示 (此种方法只能用在JDK5及以后版本(注意 INSTANCE 被声明为 volatile)，之前的版本使用“双重检查锁”会发生非预期行为)： public class Singleton { private static volatile Singleton INSTANCE = null; // Private constructor suppresses // default public constructor private Singleton() {}; //Thread safe and performance promote public static Singleton getInstance() { if(INSTANCE == null){ synchronized(Singleton.class){ // When more than two threads run into the first null check same time, // to avoid instanced more than one time, it needs to be checked again. if(INSTANCE == null){ INSTANCE = new Singleton(); } } } return INSTANCE; } } 例子 Singleton public class Singleton { private static Singleton sing; public Singleton() { } public static Singleton getInstance(){ if(sing==null){ sing=new Singleton(); } return sing; } } Test public class Test { public static void main(String[] args) { Singleton s1=Singleton.getInstance(); Singleton s2=Singleton.getInstance(); System.out.println(s1); System.out.println(s2); } } 运行结果： Singleton@677327b6 Singleton@677327b6 ","date":"2019-08-23","objectID":"/single-case-pattern/:3:0","tags":["pattern"],"title":"创建型模式-单例模式","uri":"/single-case-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-23","objectID":"/builder-pattern/:0:0","tags":["pattern"],"title":"创建型模式-建造者模式","uri":"/builder-pattern/"},{"categories":["设计模式"],"content":"生成器模式 生成器模式（英：Builder Pattern）是一种设计模式，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 ","date":"2019-08-23","objectID":"/builder-pattern/:1:0","tags":["pattern"],"title":"创建型模式-建造者模式","uri":"/builder-pattern/"},{"categories":["设计模式"],"content":"适用性 在以下情况使用生成器模式： 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时； 当构造过程必须允许被构造的对象有不同的表示时。 ","date":"2019-08-23","objectID":"/builder-pattern/:2:0","tags":["pattern"],"title":"创建型模式-建造者模式","uri":"/builder-pattern/"},{"categories":["设计模式"],"content":"参与者 Builder 为创建一个Product对象的各个部件指定抽象接口。 ConcreteBuilder 实现Builder的接口以构造和装配该产品的各个部件。 定义并明确它所创建的表示。 提供一个检索产品的接口 Director 构造一个使用Builder接口的对象。 Product 表示被构造的复杂对象。ConcreateBuilder创建该产品的内部表示并定义它的装配过程。 包含定义组成部件的类，包括将这些部件装配成最终产品的接口。 ","date":"2019-08-23","objectID":"/builder-pattern/:3:0","tags":["pattern"],"title":"创建型模式-建造者模式","uri":"/builder-pattern/"},{"categories":["设计模式"],"content":"协作 客户创建Director对象，并用它所想要的Builder对象进行配置。 一旦产品部件被生成，导向器就会通知生成器。 生成器处理导向器的请求，并将部件添加到该产品中。 客户从生成器中检索产品。 ","date":"2019-08-23","objectID":"/builder-pattern/:4:0","tags":["pattern"],"title":"创建型模式-建造者模式","uri":"/builder-pattern/"},{"categories":["设计模式"],"content":"范例 /** \"Product\" */ class Pizza { private String dough = \"\"; private String sauce = \"\"; private String topping = \"\"; public void setDough (String dough) { this.dough = dough; } public void setSauce (String sauce) { this.sauce = sauce; } public void setTopping (String topping) { this.topping = topping; } } ''/** \"Abstract Builder\" */'' abstract class PizzaBuilder { protected Pizza pizza; public Pizza getPizza() { return pizza; } public void createNewPizzaProduct() { pizza = new Pizza(); } public abstract void buildDough(); public abstract void buildSauce(); public abstract void buildTopping(); } /** \"ConcreteBuilder\" */ class HawaiianPizzaBuilder extends PizzaBuilder { public void buildDough() { pizza.setDough(\"cross\"); } public void buildSauce() { pizza.setSauce(\"mild\"); } public void buildTopping() { pizza.setTopping(\"ham+pineapple\"); } } /** \"ConcreteBuilder\" */ class SpicyPizzaBuilder extends PizzaBuilder { public void buildDough() { pizza.setDough(\"pan baked\"); } public void buildSauce() { pizza.setSauce(\"hot\"); } public void buildTopping() { pizza.setTopping(\"pepperoni+salami\"); } } ''/** \"Director\" */'' class Waiter { private PizzaBuilder pizzaBuilder; public void setPizzaBuilder (PizzaBuilder pb) { pizzaBuilder = pb; } public Pizza getPizza() { return pizzaBuilder.getPizza(); } public void constructPizza() { pizzaBuilder.createNewPizzaProduct(); pizzaBuilder.buildDough(); pizzaBuilder.buildSauce(); pizzaBuilder.buildTopping(); } } /** A customer ordering a pizza. */ class BuilderExample { public static void main(String[] args) { Waiter waiter = new Waiter(); PizzaBuilder hawaiian_pizzabuilder = new HawaiianPizzaBuilder(); PizzaBuilder spicy_pizzabuilder = new SpicyPizzaBuilder(); waiter.setPizzaBuilder ( hawaiian_pizzabuilder ); waiter.constructPizza(); Pizza pizza = waiter.getPizza(); } } 例子 Product public class Person { private String head; private String body; private String foot; public String getHead() { return head; } public void setHead(String head) { this.head = head; } public String getBody() { return body; } public void setBody(String body) { this.body = body; } public String getFoot() { return foot; } public void setFoot(String foot) { this.foot = foot; } } Builder public interface PersonBuilder { void buildHead(); void buildBody(); void buildFoot(); Person buildPerson(); } Builder的实现类 public class ManBuilder implements PersonBuilder{ Person person; public ManBuilder() { person = new Person(); } @Override public void buildHead() { person.setHead(\"建造男人的头\"); } @Override public void buildBody() { person.setBody(\"建造男人的身体\"); } @Override public void buildFoot() { person.setFoot(\"建造男人的脚\"); } @Override public Person buildPerson() { return person; } } Director public class PersonDirector { public Person constructPerson(PersonBuilder pb) { pb.buildHead(); pb.buildBody(); pb.buildFoot(); return pb.buildPerson(); } } Test public class Test { public static void main(String[] args) { PersonDirector pd = new PersonDirector(); Person person = pd.constructPerson(new ManBuilder()); System.out.println(person.getHead()); System.out.println(person.getBody()); System.out.println(person.getFoot()); } } 运行结果 建造男人的头 建造男人的身体 建造男人的脚 ","date":"2019-08-23","objectID":"/builder-pattern/:5:0","tags":["pattern"],"title":"创建型模式-建造者模式","uri":"/builder-pattern/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-19","objectID":"/abstract-factory/:0:0","tags":["pattern"],"title":"创建型模式-抽象工厂","uri":"/abstract-factory/"},{"categories":["设计模式"],"content":"抽象工厂 抽象工厂模式（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。 举个例子来说，比如一个抽象工厂类叫做DocumentCreator（文档创建器），此类提供创建若干种产品的接口，包括createLetter()（创建信件）和createResume()（创建简历）。其中，createLetter()返回一个Letter（信件），createResume()返回一个Resume（简历）。系统中还有一些DocumentCreator的具体实现类，包括FancyDocumentCreator和ModernDocumentCreator。这两个类对DocumentCreator的两个方法分别有不同的实现，用来创建不同的“信件”和“简历”（用FancyDocumentCreator的实例可以创建FancyLetter和FancyResume，用ModernDocumentCreator的实例可以创建ModernLetter和ModernResume）。这些具体的“信件”和“简历”类均继承自抽象类，即Letter和Resume类。客户端需要创建“信件”或“简历”时，先要得到一个合适的DocumentCreator实例，然后调用它的方法。一个工厂中创建的每个对象都是同一个主题的（“fancy”或者“modern”）。客户端程序只需要知道得到的对象是“信件”或者“简历”，而不需要知道具体的主题，因此客户端程序从抽象工厂DocumentCreator中得到了Letter或Resume类的引用，而不是具体类的对象引用。 “工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。 使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作” ","date":"2019-08-19","objectID":"/abstract-factory/:1:0","tags":["pattern"],"title":"创建型模式-抽象工厂","uri":"/abstract-factory/"},{"categories":["设计模式"],"content":"定义 抽象工厂模式的实质是“提供接口，创建一系列相关或独立的对象，而不指定这些对象的具体类。 ","date":"2019-08-19","objectID":"/abstract-factory/:2:0","tags":["pattern"],"title":"创建型模式-抽象工厂","uri":"/abstract-factory/"},{"categories":["设计模式"],"content":"使用 具体的工厂决定了创建对象的具体类型，而且工厂就是对象实际创建的地方（比如在C++中，用“new”操作符创建对象）。然而，抽象工厂只返回一个指向创建的对象的抽象引用（或指针）。 这样，客户端程序调用抽象工厂引用的方法，由具体工厂完成对象创建，然后客户端程序得到的是抽象产品的引用。如此使客户端代码与对象的创建分离开来。 因为工厂仅仅返回一个抽象产品的引用（或指针），所以客户端程序不知道（也不会牵绊于）工厂创建对象的具体类型。然而，工厂知道具体对象的类型；例如，工厂可能从配置文件中读取某种类型。这时，客户端没有必要指定具体类型，因为已经在配置文件中指定了。通常，这意味着： 客户端代码不知道任何具体类型，也就没必要引入任何相关的头文件或类定义。客户端代码仅仅处理抽象类型。工厂确实创建了具体类型的对象，但是客户端代码仅使用这些对象的抽象接口来访问它们。 如果要增加一个具体类型，只需要修改客户端代码使用另一个工厂即可，而且这个修改通常只是一个文件中的一行代码。不同的工厂创建不同的具体类型的对象，但是和以前一样返回一个抽象类型的引用（或指针），因此客户端代码的其他部分不需要任何改动。这样比修改客户端代码创建新类型的对象简单多了。如果是后者的话，需要修改代码中每一个创建这种对象的地方（而且需要注意的是，这些地方都知道对象的具体类型，而且需要引入具体类型的头文件或类定义）。如果所有的工厂对象都存储在全局的单例对象中，所有的客户端代码到这个单例中访问需要的工厂，那么，更换工厂就非常简单了，仅仅需要更改这个单例对象即可。 ","date":"2019-08-19","objectID":"/abstract-factory/:3:0","tags":["pattern"],"title":"创建型模式-抽象工厂","uri":"/abstract-factory/"},{"categories":["设计模式"],"content":"代码举例 假设我们有两种产品接口 Button 和 Border ，每一种产品都支持多种系列，比如 Mac 系列和 Windows 系列。这样每个系列的产品分别是 MacButton, WinButton, MacBorder, WinBorder 。为了可以在运行时刻创建一个系列的产品族，我们可以为每个系列的产品族创建一个工厂 MacFactory 和 WinFactory 。每个工厂都有两个方法 CreateButton 和 CreateBorder 并返回对应的产品，可以将这两个方法抽象成一个接口 AbstractFactory 。这样在运行时刻我们可以选择创建需要的产品系列。 public interface Button {} public interface Border {} //实现抽象类 public class MacButton implements Button {} public class MacBorder implements Border {} public class WinButton implements Button {} public class WinBorder implements Border {} //接着实现工厂 public class MacFactory { public static Button createButton() { return new MacButton(); } public static Border createBorder() { return new MacBorder(); } } public class WinFactory { public static Button createButton() { return new WinButton(); } public static Border createBorder() { return new WinBorder(); } } ","date":"2019-08-19","objectID":"/abstract-factory/:4:0","tags":["pattern"],"title":"创建型模式-抽象工厂","uri":"/abstract-factory/"},{"categories":["设计模式"],"content":"适用性 在以下情况可以考虑使用抽象工厂模式： 一个系统要独立于它的产品的创建、组合和表示时。 一个系统要由多个产品系列中的一个来配置时。 需要强调一系列相关的产品对象的设计以便进行联合使用时。 提供一个产品类库，而只想显示它们的接口而不是实现时。 ","date":"2019-08-19","objectID":"/abstract-factory/:5:0","tags":["pattern"],"title":"创建型模式-抽象工厂","uri":"/abstract-factory/"},{"categories":["设计模式"],"content":"优点 具体产品从客户代码中被分离出来 容易改变产品的系列 将一个系列的产品族统一到一起创建 ","date":"2019-08-19","objectID":"/abstract-factory/:6:0","tags":["pattern"],"title":"创建型模式-抽象工厂","uri":"/abstract-factory/"},{"categories":["设计模式"],"content":"缺点 在产品族中扩展新的产品是很困难的，它需要修改抽象工厂的接口 例子 public interface ICat { void eat(); } public interface IDog { void eat(); } public interface IAnimalFactory { ICat createCat(); IDog createDog(); } public class BlackCat implements ICat { @Override public void eat() { System.out.println(\"黑猫在吃。。\"); } } public class BlackDog implements IDog { @Override public void eat() { System.out.println(\"黑狗在吃。。\"); } } public class BlackAnimalFactory implements IAnimalFactory { @Override public ICat createCat() { return new BlackCat(); } @Override public IDog createDog() { return new BlackDog(); } } public class WhiteCat implements ICat { @Override public void eat() { System.out.println(\"白猫在吃。。\"); } } public class WhiteDog implements IDog { @Override public void eat() { System.out.println(\"白狗在吃。。\"); } } public class WhiteAnimalFactory implements IAnimalFactory { @Override public ICat createCat() { return new WhiteCat(); } @Override public IDog createDog() { return new WhiteDog(); } } 测试类 public class Test { public static void main(String[] args) { IAnimalFactory blackAnimalFactory = new BlackAnimalFactory(); ICat blackCat = blackAnimalFactory.createCat(); blackCat.eat(); IDog blackDog = blackAnimalFactory.createDog(); blackDog.eat(); IAnimalFactory whiteAnimalFactory = new WhiteAnimalFactory(); ICat whiteCat = whiteAnimalFactory.createCat(); whiteCat.eat(); IDog whiteDog = whiteAnimalFactory.createDog(); whiteDog.eat(); } } 结果： 黑猫在吃。。 黑狗在吃。。 白猫在吃。。 白狗在吃。。 ","date":"2019-08-19","objectID":"/abstract-factory/:7:0","tags":["pattern"],"title":"创建型模式-抽象工厂","uri":"/abstract-factory/"},{"categories":["设计模式"],"content":"维基百科 ","date":"2019-08-19","objectID":"/factory-method/:0:0","tags":["pattern"],"title":"创建型模式-工厂方法","uri":"/factory-method/"},{"categories":["设计模式"],"content":"工厂方法 工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。” 创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。 对象创建中的有些过程包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁的概念。 ","date":"2019-08-19","objectID":"/factory-method/:1:0","tags":["pattern"],"title":"创建型模式-工厂方法","uri":"/factory-method/"},{"categories":["设计模式"],"content":"工厂 在面向对象程序设计中，工厂通常是一个用来创建其他对象的对象。工厂是构造方法的抽象，用来实现不同的分配方案。 工厂对象通常包含一个或多个方法，用来创建这个工厂所能创建的各种类型的对象。这些方法可能接收参数，用来指定对象创建的方式，最后返回创建的对象。 有时，特定类型对象的控制过程比简单地创建一个对象更复杂。在这种情况下，工厂对象就派上用场了。工厂对象可能会动态地创建产品类的对象，或者从对象池中返回一个对象，或者对所创建的对象进行复杂的配置，或者应用其他的操作。 这些类型的对象很有用。几个不同的设计模式都应用了工厂的概念，并可以使用在很多语言中。例如，在《设计模式》一书中，像工厂方法模式、抽象工厂模式、生成器模式，甚至是单例模式都应用了工厂的概念。 ","date":"2019-08-19","objectID":"/factory-method/:2:0","tags":["pattern"],"title":"创建型模式-工厂方法","uri":"/factory-method/"},{"categories":["设计模式"],"content":"代码举例 例如，有一个Button类表示按钮，另有它的两个子类WinButton和MacButton分别代表Windows和Mac风格的按钮，那么这几个类和用于创建它们的工厂类在Java中可以如下实现 //Button class Button{/* ...*/} class WinButton extends Button{/* ...*/} class MacButton extends Button{/* ...*/} //他们的工厂类 interface ButtonFactory{ abstract Button createButton(); } class WinButtonFactory implements ButtonFactory{ Button createButton(){ return new WinButton(); } } class MacButtonFactory implements ButtonFactory{ Button createButton(){ return new MacButton(); } } ","date":"2019-08-19","objectID":"/factory-method/:3:0","tags":["pattern"],"title":"创建型模式-工厂方法","uri":"/factory-method/"},{"categories":["设计模式"],"content":"简单工厂 普通的工厂方法模式通常伴随着对象的具体类型与工厂具体类型的一一对应，客户端代码根据需要选择合适的具体类型工厂使用。然而，这种选择可能包含复杂的逻辑。这时，可以创建一个单一的工厂类，用以包含这种选择逻辑，根据参数的不同选择实现不同的具体对象。这个工厂类不需要由每个具体产品实现一个自己的具体的工厂类，所以可以将工厂方法设置为静态方法。 而且，工厂方法封装了对象的创建过程。如果创建过程非常复杂（比如依赖于配置文件或用户输入），工厂方法就非常有用了。 比如，一个程序要读取图像文件。程序支持多种图像格式，每种格式都有一个对应的ImageReader类用来读取图像。程序每次读取图像时，需要基于文件信息创建合适类型的ImageReader。这个选择逻辑可以包装在一个简单工厂中： public class ImageReaderFactory { public static ImageReader imageReaderFactoryMethod(InputStream is) { ImageReader product = null; int imageType = determineImageType(is); switch (imageType) { case ImageReaderFactory.GIF: product = new GifReader(is); case ImageReaderFactory.JPEG: product = new JpegReader(is); //... } return product; } } ","date":"2019-08-19","objectID":"/factory-method/:4:0","tags":["pattern"],"title":"创建型模式-工厂方法","uri":"/factory-method/"},{"categories":["设计模式"],"content":"适用性 下列情况可以考虑使用工厂方法模式： 创建对象需要大量重复的代码。 创建对象需要访问某些信息，而这些信息不应该包含在复合类中。 创建对象的生命周期必须集中管理，以保证在整个程序中具有一致的行为。 工厂方法模式常见于工具包和框架中，在这些库中可能需要创建客户端代码实现的具体类型的对象。 平行的类层次结构中，常常需要一个层次结构中的对象能够根据需要创建另一个层次结构中的对象。 工厂方法模式可以用于测试驱动开发，从而允许将类放在测试中。举例来说，Foo这个类创建了一个Dangerous对象，但是Dangerous对象不能放在自动的单元测试中（可能它需要访问产品数据库，而这个数据库不是随时能够访问到的）。所以，就可以把Dangerous对象的创建交由Foo类的一个方法（虚函数）createDangerous完成。为了测试，再创建一个Foo的一个子类TestFoo，重写createDangerous方法，在方法中创建并返回一个FakeDangerous（Dangerous的子类），而这是一个模拟对象。这样，单元测试就可以使用TestFoo来测试Foo的功能，从而避免了使用Dangerous对象带来的副作用。 ","date":"2019-08-19","objectID":"/factory-method/:5:0","tags":["pattern"],"title":"创建型模式-工厂方法","uri":"/factory-method/"},{"categories":["设计模式"],"content":"局限性 使用工厂方法有三个局限，第一个与代码重构有关，另外两个与类的扩展有关。 第一个局限是，重构已经存在的类会破坏客户端代码。例如，Complex类是一个标准的类，客户端使用构造方法将其实例化。可能会有很多这样的客户端代码： Complex c = new Complex(-1, 0); 一旦Complex的编写者意识到Complex的实例化应该使用工厂方法实现，他会将Complex的构造方法设为私有。而此时使用它的构造方法的客户端代码就都失效了。 第二个局限是，因为工厂方法所实例化的类具有私有的构造方法，所以这些类就不能扩展了。因为任何子类都必须调用父类的构造方法，但父类的私有构造方法是不能被子类调用的。 第三个局限是，如果确实扩展了工厂方法所实例化的类（例如将构造方法设为保护的，虽然有风险但也是可行的），子类必须具有所有工厂方法的一套实现。例如，在上述Complex的例子中，如果Complex有了一个子类StrangeComplex，那么StrangeComplex必须提供属于它自己的所有工厂方法，否则 StrangeComplex.fromPolar(1, pi); 将会返回一个Complex（父类）的实例，而不是所希望的子类实例。但有些语言的反射特性可以避免这个问题。 通过修改底层编程语言，使工厂方法称为第一类的类成员，可以缓解这三个问题。 例子 Product 定义工厂方法所创建的对象的接口。 public interface Work { void doWork(); } ConcreteProduct 实现Product接口。 public class StudentWork implements Work { @Override public void doWork() { System.out.println(\"学生写作业\"); } } public class TeachWork implements Work { @Override public void doWork() { System.out.println(\"老师审批作业\"); } } Creator 声明工厂方法，该方法返回一个Product类型的对象 Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象。 可以调用工厂方法以创建一个Product对象。 public interface IWorkFactory { Work getWork(); } ConcreteCreator 重定义工厂方法以返回一个ConcreteProduct实例。 public class StudentFactory implements IWorkFactory{ @Override public Work getWork() { return new StudentWork(); } } public class TeacherFactory implements IWorkFactory { @Override public Work getWork() { return new TeachWork(); } } Test public class Test { public static void main(String[] args) { IWorkFactory studentFactory = new StudentFactory(); studentFactory.getWork().doWork(); IWorkFactory teacherFactory = new TeacherFactory(); teacherFactory.getWork().doWork(); } } Result 学生写作业 老师审批作业 ","date":"2019-08-19","objectID":"/factory-method/:6:0","tags":["pattern"],"title":"创建型模式-工厂方法","uri":"/factory-method/"},{"categories":["JAVA基础"],"content":"回调一般用于层间协作，上层将本层函数安装在下层，这个函数就是回调，而下层在一定条件下触发回调。例如作为一个驱动，是一个底层，他在收到一个数据时，除了完成本层的处理工作外，还将进行回调，将这个数据交给上层应用层来做进一步处理，这在分层的数据通信中很普遍。 例如老板A对员工B说，我现在交给你一个任务，并且我把我的电话号码给你，你一旦完成任务就给我打电话。 1.创建一个回调接口 /** * 一个回调接口 */ public interface CallBack { public void doEvent(); } 2.创建回调接口的实现类，此例中，员工干完活后还要干什么事情是老板说了算的。 /** * 回调接口的实现类 */ public class Boss implements CallBack{ @Override public void doEvent() { System.out.println(\"打电话给老板，告知已完成工作了\"); } } 3.创建控制类，也就是本例中的员工对象，他要持有老板的地址(即回调接口) /** * 控制类，也就是本例中的员工对象，他要持有老板的地址(即回调接口) */ public class Employee { CallBack callBack; public Employee(CallBack callBack){ this.callBack=callBack; } public void doWork(){ System.out.println(\"玩命干活中\"); callBack.doEvent(); } } 4.测试类 /** * 测试类 */ public class TestMain { public static void main(String[] args) { Employee employee = new Employee(new Boss()); employee.doWork(); } } 运行结果： 玩命干活中 打电话给老板，告知已完成工作了 参考： https://www.cnblogs.com/xujian2014/p/5088072.html ","date":"2019-08-17","objectID":"/interface-callback/:0:0","tags":["interface"],"title":"java接口回调","uri":"/interface-callback/"},{"categories":["数据库"],"content":"表和数据 CREATE TABLE `sqltest` ( `id` int(11) NOT NULL, `name` varchar(45) NOT NULL, `age` int(11) NOT NULL, `score` int(11) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `id_UNIQUE` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO `sqltest` VALUES (1,'土豆',18,100),(2,'地瓜',18,100),(3,'李斯',20,60),(4,'韩非',20,60),(5,'荀子',50,90),(6,'君莫笑',22,80),(7,'寒烟柔',21,80),(8,'包子',26,30),(9,'剑圣',30,0); ","date":"2019-08-17","objectID":"/mysql-sort/:1:0","tags":["MySQL"],"title":"mysql高级排序","uri":"/mysql-sort/"},{"categories":["数据库"],"content":"排名(row_number) 按分数排序，拿到名次(成绩相同排名不并列) SQL: use sqltest; select st.*,(@rownum:=@rownum+1) as rownum from sqltest st,(select @rownum:=0) potato order by score; 结果： 解释：设置一个伪列@rownum，从1开始计数，依次加1;(select @rownum:=0) potato ,一定要起别名 注意：这是从小到大排；如果需要从大到小的话，order by score desc。 ","date":"2019-08-17","objectID":"/mysql-sort/:2:0","tags":["MySQL"],"title":"mysql高级排序","uri":"/mysql-sort/"},{"categories":["数据库"],"content":"排名(Rank) 按分数排序，拿到名次(成绩相同排名并列，有跳数,比如2个100，1个99，排名就是1,1,3) SQL: use sqltest; select st.*,@rownum:=@rownum+1 as rownum, @curnum:=(case when @prescore=st.score then @curnum else @rownum end) as ScoreRank, @prescore:=st.score as prescore from sqltest st,(select @rownum:=0,@curnum:=0,@prescore:=null) potato order by st.score desc; 结果： 解释：设置一个伪列@rownum，@curnum就是当前的名次，@prescore记录前一个分数与当前行的分数进行比较，相等就用上一个的排名，不相等就用一直增加的那个数 ","date":"2019-08-17","objectID":"/mysql-sort/:3:0","tags":["MySQL"],"title":"mysql高级排序","uri":"/mysql-sort/"},{"categories":["JAVA基础"],"content":"TCP 客户端套接字：Socket 服务端套接字：ServerSocket TCP（传输控制协议）一种基于连接的通信协议。可靠传输 ","date":"2019-07-30","objectID":"/java-simple-chat/:0:0","tags":["TCP","UDP"],"title":"TCP、UDP简单聊天","uri":"/java-simple-chat/"},{"categories":["JAVA基础"],"content":"Server package com.tcp; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * 服务器端 */ public class Server { public static void main(String[] args) { ServerSocket serverSocket = null; try { serverSocket = new ServerSocket(12345); System.out.println(\"服务启动：\"+serverSocket.getInetAddress().getHostAddress()+\":\"+serverSocket.getLocalPort()); Socket accept = serverSocket.accept(); System.out.println(\"客户端：\"+accept.getInetAddress().getHostAddress()+\":\"+accept.getLocalPort()); BufferedReader sis = new BufferedReader(new InputStreamReader(System.in)); BufferedReader is = new BufferedReader(new InputStreamReader(accept.getInputStream())); PrintWriter os = new PrintWriter(new OutputStreamWriter(accept.getOutputStream())); while (true){ String line; if ((line=is.readLine())!=null){ System.out.println(\"收到客户端：\"+line); if (line.equals(\"bye\")){ break; }else { os.println(sis.readLine()); os.flush(); } } } is.close(); os.close(); accept.close(); } catch (IOException e) { e.printStackTrace(); }finally { try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } ","date":"2019-07-30","objectID":"/java-simple-chat/:1:0","tags":["TCP","UDP"],"title":"TCP、UDP简单聊天","uri":"/java-simple-chat/"},{"categories":["JAVA基础"],"content":"Client package com.tcp; import java.io.*; import java.net.Socket; /** * 客户端 */ public class Client { public static void main(String[] args) { try { Socket socket = new Socket(\"127.0.0.1\",12345); BufferedReader sis = new BufferedReader(new InputStreamReader(System.in)); BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter os = new PrintWriter(new OutputStreamWriter(socket.getOutputStream())); String line; while (true){ if ((line=sis.readLine())!=null){ if (\"bye\".equals(line)){ System.exit(0); } os.println(line); os.flush(); } String readLine = is.readLine(); System.out.println(\"收到服务端：\"+readLine); } } catch (IOException e) { e.printStackTrace(); } } } UDP UDP采用Datagram（数据报）传输，数据包是一种尽力而为的传送数据的方式，它只是 把数据的目的地记录在数据包中，然后就直接放在网络上，系统不保证数据是否能安全到达，或者什么时候可以送到，它并不保证传送质量。 Datagram（数据报）是网络层数据单元在介质上传输信息的一种逻辑分组格式，它是一种在网络中传播的、独立的、自身包含地址信息的消息，它能够到达目的地、到达时间、到达时内容是否会变化是不能准确知道的。它的通信双方不需要建立连接，对于一些不需要很高质量的应用程序来说，数据报通信是一个非常好的选择。还有就是对实时性很高的情况，比如在实时音频和视频应用中，数据包的丢失和位置是静态的，是可以被人们所忍受的，这时就可以利用UDP协议传输。 DatagramSocket（数据报套接字）工作包含了3个信息类：DatagramPacket、DatagramSocket和MulticastSocket。DatagramPacket对象描绘了数据报地址信息，DatagramSocket表示客户程序和服务程序报套接字，MulticastSocket描绘了能够进行多点传输的数据报套接字。 ","date":"2019-07-30","objectID":"/java-simple-chat/:2:0","tags":["TCP","UDP"],"title":"TCP、UDP简单聊天","uri":"/java-simple-chat/"},{"categories":["JAVA基础"],"content":"Server package com.udp; import java.net.DatagramPacket; import java.net.DatagramSocket; public class Server { public static void main(String[] args) { try { DatagramSocket socket = new DatagramSocket(12345); byte[] bytes = new byte[1024]; DatagramPacket receivePacket = new DatagramPacket(bytes, bytes.length); System.out.println(\"开始接收包。。。\"); while (true){ socket.receive(receivePacket); String name = receivePacket.getAddress().toString(); System.out.println(\"来自主机：\"+name+\"\\n端口：\"+receivePacket.getPort()); String s = new String(receivePacket.getData(),0,receivePacket.getLength()); System.out.println(\"接收到数据：\"+s); } }catch (Exception e){ e.printStackTrace(); } } } ","date":"2019-07-30","objectID":"/java-simple-chat/:3:0","tags":["TCP","UDP"],"title":"TCP、UDP简单聊天","uri":"/java-simple-chat/"},{"categories":["JAVA基础"],"content":"Client package com.udp; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; public class Client { public static void main(String[] args) { try { DatagramSocket socket = new DatagramSocket(); InetAddress host = InetAddress.getByName(\"localhost\"); String msg = \"hello, I'm client\"; DatagramPacket sendPacket = new DatagramPacket(msg.getBytes(),msg.length(),host,12345); socket.send(sendPacket); }catch (Exception e){ e.printStackTrace(); } } } DatagramSocket只允许数据报发送一个目的地址，MulticastSocket允许数据报以广播的形式发送到该端口的所有客户。 ","date":"2019-07-30","objectID":"/java-simple-chat/:4:0","tags":["TCP","UDP"],"title":"TCP、UDP简单聊天","uri":"/java-simple-chat/"},{"categories":["JAVA基础"],"content":"MultiServer package com.udp; import java.net.DatagramPacket; import java.net.InetAddress; import java.net.MulticastSocket; public class MultiServer { public static void main(String[] args) { try { MulticastSocket socket = new MulticastSocket(12345); InetAddress group = InetAddress.getByName(\"231.0.0.0\"); socket.joinGroup(group); //接收数据报 for(int i=0;i\u003c100;i++){ byte[] bytes = new byte[256]; DatagramPacket receivePacket = new DatagramPacket(bytes, bytes.length); socket.receive(receivePacket); byte[] bytes1 = new byte[receivePacket.getLength()]; System.arraycopy(receivePacket.getData(),0,bytes1,0,receivePacket.getLength()); System.out.println(new String(bytes1)); } socket.leaveGroup(group); socket.close(); }catch (Exception e){ e.printStackTrace(); } } } ","date":"2019-07-30","objectID":"/java-simple-chat/:5:0","tags":["TCP","UDP"],"title":"TCP、UDP简单聊天","uri":"/java-simple-chat/"},{"categories":["JAVA基础"],"content":"MultiClient package com.udp; import java.net.DatagramPacket; import java.net.InetAddress; import java.net.MulticastSocket; public class MultiClient { public static void main(String[] args) { try { MulticastSocket socket = new MulticastSocket(); InetAddress group = InetAddress.getByName(\"231.0.0.0\"); byte[] bytes = new byte[0]; DatagramPacket sendPacket = new DatagramPacket(bytes, 0, group, 12345); for(int i=0;i\u003c5;i++){ byte[] bytes1 = (\"Data line \"+i).getBytes(); sendPacket.setData(bytes1); sendPacket.setLength(bytes1.length); socket.send(sendPacket); } socket.close(); }catch (Exception e){ e.printStackTrace(); } } } 参考： https://www.cnblogs.com/benjamin77/p/9147146.html https://blog.51cto.com/aku28907/1782137 ","date":"2019-07-30","objectID":"/java-simple-chat/:6:0","tags":["TCP","UDP"],"title":"TCP、UDP简单聊天","uri":"/java-simple-chat/"},{"categories":["JAVA基础"],"content":"java.lang.Class 创建一个类，通过编译(javac.exe),生成对应的.class文件。之后使用java.exe加载(JVM的类加载器完成)， 此.class文件加载到内存以后，就是一个运行时类，存在缓冲区。那么这个运行时类本身就是一个Class的实例! 一个运行时类只加载一次。 ","date":"2019-07-28","objectID":"/java-relfect/:0:0","tags":["Relect"],"title":"反射","uri":"/java-relfect/"},{"categories":["JAVA基础"],"content":"举例 import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class RelfectTest{ public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException { Class\u003cPerson\u003e personClass = Person.class; //通过反射创建对象 Person person = personClass.newInstance(); System.out.println(person); //通过反射赋值-------public属性 Field name = personClass.getField(\"name\"); name.set(person,\"土豆\"); System.out.println(person); //通过反射赋值------private或者默认(不写)属性 Field age = personClass.getDeclaredField(\"age\"); age.setAccessible(true); age.set(person,18); System.out.println(person); //通过反射调用指定方法--没有参数 Method show = personClass.getMethod(\"show\"); show.invoke(person); //通过反射调用指定方法--有参数 Method say = personClass.getMethod(\"say\", String.class); say.invoke(person,\"welcome\"); } } class Person{ public String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return name+\"----\"+age; } public void show(){ System.out.println(\"Person类的show...\"); } public void say(String word){ System.out.println(name+\" \"+word); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } ","date":"2019-07-28","objectID":"/java-relfect/:1:0","tags":["Relect"],"title":"反射","uri":"/java-relfect/"},{"categories":["JAVA基础"],"content":"拓展 Person类 package com.cherry; public class Person{ public String name; private int age; int id; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return name+\"----\"+age; } public void show() throws Exception{ System.out.println(\"Person类的show...\"); } public void say(String word){ System.out.println(name+\" \"+word); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } jdbc.properties username=root password=1234 测试类 package com.cherry; import org.junit.Test; import java.io.IOException; import java.io.InputStream; import java.lang.annotation.Annotation; import java.lang.reflect.*; import java.util.Arrays; import java.util.Properties; public class RelfectionTest { /** * 类加载器，加载配置文件 */ @Test public void test1() throws IOException { ClassLoader classLoader = this.getClass().getClassLoader(); InputStream inputStream = classLoader.getResourceAsStream(\"com\\\\cherry\\\\jdbc.properties\"); Properties properties = new Properties(); properties.load(inputStream); String username = properties.getProperty(\"username\"); System.out.println(\"username=\"+username); String password = properties.getProperty(\"password\"); System.out.println(\"password=\"+password); } /** * 测试同一个实例 */ @Test public void test2() throws ClassNotFoundException, IllegalAccessException, InstantiationException { Class\u003cPerson\u003e personClass1 = Person.class; String className=\"com.cherry.Person\"; Class\u003c?\u003e personClass2 = Class.forName(className); ClassLoader classLoader = this.getClass().getClassLoader(); Class\u003c?\u003e personClass3 = classLoader.loadClass(className); System.out.println(personClass1==personClass2); //true System.out.println(personClass1==personClass3); //true Person person1 = personClass1.newInstance(); Person person2 = (Person) personClass2.newInstance(); System.out.println(person1==person2); //false } /** * newInstance()是调用了无参构造 * @throws ClassNotFoundException * @throws IllegalAccessException * @throws InstantiationException */ @Test public void test3() throws ClassNotFoundException, IllegalAccessException, InstantiationException { String className=\"com.cherry.Person\"; Class\u003c?\u003e personClass = Class.forName(className); Object o = personClass.newInstance(); Person person = (Person) o; System.out.println(person); } @Test public void test4(){ Class\u003cPerson\u003e personClass = Person.class; //getFields---获取此类和父类的public属性 Field[] fields = personClass.getFields(); for(Field f: fields){ System.out.println(f.getName()); } System.out.println(\"----------\"); //getDeclaredFields---获取此类声明的属性 Field[] fields1 = personClass.getDeclaredFields(); for(Field f: fields1){ System.out.println(f.getName()); } System.out.println(\"-----------\"); /** * 权限修饰符 变量类型 变量名 */ Field[] fields2 = personClass.getDeclaredFields(); for(Field f: fields2){ int modifiers = f.getModifiers(); String s = Modifier.toString(modifiers); System.out.print(s+\"--\"); Class\u003c?\u003e type = f.getType(); System.out.print(type.getName()+\"--\"); System.out.println(f.getName()); } } /** * 注解 权限修饰符 返回值类型 方法名 形参列表 异常 */ @Test public void test5(){ Class\u003cPerson\u003e personClass = Person.class; Method[] declaredMethods = personClass.getDeclaredMethods(); for(Method m:declaredMethods){ //1.注解 Annotation[] annotations = m.getAnnotations(); for(Annotation a:annotations){ System.out.println(a); } //2.权限修饰符 int modifiers = m.getModifiers(); System.out.print(Modifier.toString(modifiers)+\"--\"); //3.返回值类型 Class\u003c?\u003e returnType = m.getReturnType(); System.out.print(returnType.getName()+\"--\"); //4.方法名 String name = m.getName(); System.out.print(name+\"--\"); //5.形参列表 Parameter[] parameters = m.getParameters(); System.out.print(Arrays.asList(parameters)+\"--\"); //6.异常 Class\u003c?\u003e[] exceptionTypes = m.getExceptionTypes(); System.out.print(Arrays.asList(exceptionTypes)); System.out.println(\"-----------\"); } } @Test public void test6(){ Class\u003cPerson\u003e personClass = Person","date":"2019-07-28","objectID":"/java-relfect/:2:0","tags":["Relect"],"title":"反射","uri":"/java-relfect/"},{"categories":["JAVA基础"],"content":"静态代理 package com.proxy; //静态代理模式 //接口 interface ClothFactory{ public void productCloth(); } //被代理类 class NickClothFactory implements ClothFactory{ @Override public void productCloth() { System.out.println(\"Nick在生产衣服\"); } } //代理类 class ProxyFactory implements ClothFactory{ ClothFactory clothFactory; public ProxyFactory(ClothFactory clothFactory) { this.clothFactory = clothFactory; } @Override public void productCloth() { System.out.println(\"代理类执行了。。。\"); clothFactory.productCloth(); } } public class StaticProxy { public static void main(String[] args) { NickClothFactory nick = new NickClothFactory();//创建被代理类的对象 ProxyFactory proxy = new ProxyFactory(nick);//创建代理类的对象 proxy.productCloth(); } } ","date":"2019-07-28","objectID":"/java-relfect/:3:0","tags":["Relect"],"title":"反射","uri":"/java-relfect/"},{"categories":["JAVA基础"],"content":"动态代理 package com.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; /** * 动态代理的使用 */ interface Subject{ void action(); } //被代理类 class RealSubject implements Subject{ @Override public void action() { System.out.println(\"被代理类的action。。。\"); } } class MyInvocationHandler implements InvocationHandler{ Object obj;//实现了接口的被代理类的对象的声明 //1.给被代理的对象实例化2.返回一个代理类的对象 public Object blind(Object obj){ this.obj=obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),this); } //当通过代理类的对象发起对被重写的方法的调用时，都会转换为对如下的invoke方法的调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object invoke = method.invoke(obj, args); return invoke; } } public class MovingProxy { public static void main(String[] args) { //1.被代理类的对象 RealSubject real = new RealSubject(); //2.创建一个实现了InvocationHandler接口的类的对象 MyInvocationHandler handler = new MyInvocationHandler(); //3.调用blind()方法，动态的返回一个同样实现了real所在类实现的接口的代理类的对象 Object blind = handler.blind(real); Subject sub = (Subject)blind; sub.action();//转到对InvocationHandler接口的实现类的invoke()方法的调用 NickClothFactory nick = new NickClothFactory(); ClothFactory clothFactory = (ClothFactory) handler.blind(nick); clothFactory.productCloth(); } } ","date":"2019-07-28","objectID":"/java-relfect/:4:0","tags":["Relect"],"title":"反射","uri":"/java-relfect/"},{"categories":["JAVA基础"],"content":"动态代理和aop package com.aop; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; interface Human{ void info(); void fly(); } //被代理类 class SuperMan implements Human{ @Override public void info() { System.out.println(\"SuperMan---info...\"); } @Override public void fly() { System.out.println(\"SuperMan---fly...\"); } } class HumanUtil{ public void method1(){ System.out.println(\"=======方法一========\"); } public void method2(){ System.out.println(\"=======方法二========\"); } } class MyInvocationHandler implements InvocationHandler{ Object obj; public void setObject(Object obj){ this.obj=obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { HumanUtil h = new HumanUtil(); h.method1(); Object invoke = method.invoke(obj, args); h.method2(); return invoke; } } class MyProxy{ //动态的创建一个代理类的对象 public static Object getProjectInstance(Object obj){ MyInvocationHandler handler = new MyInvocationHandler(); handler.setObject(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler); } } public class AopTest { public static void main(String[] args) { SuperMan superMan = new SuperMan(); Object o = MyProxy.getProjectInstance(superMan); Human human = (Human) o; human.info(); System.out.println(); human.fly(); } } 运行结果： =======方法一======== SuperMan---info... =======方法二======== =======方法一======== SuperMan---fly... =======方法二======== ","date":"2019-07-28","objectID":"/java-relfect/:5:0","tags":["Relect"],"title":"反射","uri":"/java-relfect/"},{"categories":["JAVA基础"],"content":"==和equals ","date":"2019-07-28","objectID":"/equals-hashcode/:0:0","tags":["equals"],"title":"==和equals和hashCode","uri":"/equals-hashcode/"},{"categories":["JAVA基础"],"content":"== 基本类型：比较的是值是否相同； 引用类型：比较的是内存地址是否相同(是否是同一对象)； ","date":"2019-07-28","objectID":"/equals-hashcode/:1:0","tags":["equals"],"title":"==和equals和hashCode","uri":"/equals-hashcode/"},{"categories":["JAVA基础"],"content":"equals Object类中的equals方法 public boolean equals(Object obj) { return (this == obj); } String类重写了equals方法 public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } 举例： public class StringTest { public static void main(String[] args) { String aa=\"String\"; String bb=\"String\"; String cc=new String(\"String\"); String dd=new String(\"String\"); System.out.println(aa==bb); //true System.out.println(aa==cc); //false System.out.println(aa.equals(bb)); //true System.out.println(aa.equals(cc)); //true System.out.println(cc==dd); //false System.out.println(cc.equals(dd)); //true } } 解读：aa、bb是放在常量池中，aa和bb是同一个引用，cc是在堆内存中，dd也是在堆内存中，但是每new一个对象，新开辟一个空间，所以不是同一个引用。equals比较的是字符串内容，所以equals比较都是true 对上述程序进行修改 public class StringTest { public static void main(String[] args) { String aa=\"String\"; String bb=\"String\"; String cc=new String(\"String\"); cc=cc.intern(); String dd=new String(\"String\"); dd=dd.intern(); System.out.println(aa==bb); //true System.out.println(aa==cc); //true System.out.println(aa.equals(bb)); //true System.out.println(aa.equals(cc)); //true System.out.println(cc==dd); //true System.out.println(cc.equals(dd)); //true } } 解读：intern()方法，检查字符串池里是否存在\"String\"这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会 把\"String\"添加到字符串池中，然后再返回它的引用。 自定义类 public class StringTest { public static void main(String[] args) { Person potato1 = new Person(\"土豆\", 18); Person potato2 = new Person(\"土豆\", 18); System.out.println(potato1==potato2); //false System.out.println(potato1.equals(potato2)); //false } } class Person{ String name; Integer age; public Person() { } public Person(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 一个Person类new了两个对象，==和equals都是false。原因：==比较的是内存地址，每次new都会开辟新空间，所以false；equals其实是调用基类Object中的equals方法，本质还是比较内存地址，所以false ","date":"2019-07-28","objectID":"/equals-hashcode/:2:0","tags":["equals"],"title":"==和equals和hashCode","uri":"/equals-hashcode/"},{"categories":["JAVA基础"],"content":"重写equals方法 public class StringTest { public static void main(String[] args) { Person potato1 = new Person(\"土豆\", 18); Person potato2 = new Person(\"土豆\", 18); System.out.println(potato1==potato2); //false System.out.println(potato1.equals(potato2)); //true } } class Person{ String name; Integer age; public Person() { } public Person(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public boolean equals(Object obj) { //同一个对象，肯定相等，提高效率 if (this==obj) return true; //判断该对象是否是该类的一个对象 if (!(obj instanceof Person)){ return false; } //向下转型 Person p = (Person) obj; return this.name.equals(p.name) \u0026\u0026 this.age==p.age; } } 现在==比较还是false，经过重写equals，equals比较为true ","date":"2019-07-28","objectID":"/equals-hashcode/:3:0","tags":["equals"],"title":"==和equals和hashCode","uri":"/equals-hashcode/"},{"categories":["JAVA基础"],"content":"hashCode import java.util.HashSet; public class StringTest { public static void main(String[] args) { Person potato1 = new Person(\"土豆\", 18); Person potato2 = new Person(\"土豆\", 18); Person person = new Person(\"地瓜\",18); HashSet\u003cPerson\u003e set = new HashSet\u003c\u003e(); set.add(potato1); set.add(potato2); set.add(person); System.out.println(set); } } class Person{ String name; Integer age; public Person() { } public Person(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public boolean equals(Object obj) { //同一个对象，肯定相等，提高效率 if (this==obj) return true; //判断该对象是否是该类的一个对象 if (!(obj instanceof Person)){ return false; } //向下转型 Person p = (Person) obj; return this.name.equals(p.name) \u0026\u0026 this.age==p.age; } @Override public String toString() { return name+\"---\"+age; } } 输出结果： [土豆---18, 地瓜---18, 土豆---18] 有重复的，去重就要重写hashCode方法 import java.util.HashSet; public class StringTest { public static void main(String[] args) { Person potato1 = new Person(\"土豆\", 18); Person potato2 = new Person(\"土豆\", 18); Person person = new Person(\"地瓜\",18); HashSet\u003cPerson\u003e set = new HashSet\u003c\u003e(); set.add(potato1); set.add(potato2); set.add(person); System.out.println(set); } } class Person{ String name; Integer age; public Person() { } public Person(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public boolean equals(Object obj) { //同一个对象，肯定相等，提高效率 if (this==obj) return true; //判断该对象是否是该类的一个对象 if (!(obj instanceof Person)){ return false; } //向下转型 Person p = (Person) obj; return this.name.equals(p.name) \u0026\u0026 this.age==p.age; } @Override public String toString() { return name+\"---\"+age; } @Override public int hashCode() { int hashCode = name.toUpperCase().hashCode(); return hashCode^age; } } 运行结果： [地瓜---18, 土豆---18] 参考： https://www.cnblogs.com/skywang12345/p/3324958.html https://www.cnblogs.com/smyhvae/p/3929585.html ","date":"2019-07-28","objectID":"/equals-hashcode/:4:0","tags":["equals"],"title":"==和equals和hashCode","uri":"/equals-hashcode/"},{"categories":["JAVA基础"],"content":" 从控制台输入输出 import java.util.Scanner; public class IoTest { public static void main(String args[]){ Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(n); String s = sc.next(); System.out.println(s); String line = sc.nextLine(); System.out.println(line);//从控制台输出 } } 字节流 ","date":"2019-07-25","objectID":"/java-io/:0:0","tags":["io"],"title":"java IO流","uri":"/java-io/"},{"categories":["JAVA基础"],"content":"FileOutputStream import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.OutputStream; public class IoTest { public static void main(String args[]){ File file = new File(\"aa.txt\"); try { //FileOutputStream(File,boolean) 是否把内容追加 OutputStream out = new FileOutputStream(file); String str = \"Hello World\"; byte[] b=str.getBytes(); out.write(b); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } ","date":"2019-07-25","objectID":"/java-io/:1:0","tags":["io"],"title":"java IO流","uri":"/java-io/"},{"categories":["JAVA基础"],"content":"FileInputStream import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.InputStream; public class IoTest { public static void main(String args[]){ try { File file = new File(\"E:\"+File.separator+\"tt.txt\"); InputStream is = new FileInputStream(file); // byte[] bytes = new byte[1024]; //也可以这样 byte[] bytes = new byte[(int) file.length()]; is.read(bytes); System.out.println(new String(bytes)); //关闭流 is.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } ","date":"2019-07-25","objectID":"/java-io/:2:0","tags":["io"],"title":"java IO流","uri":"/java-io/"},{"categories":["JAVA基础"],"content":"BufferedOutputStream import java.io.*; public class IoTest { public static void main(String args[]){ File file = new File(\"aa.txt\"); try { OutputStream out = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(out); byte[] bytes = \"土豆，土豆，呼叫土豆\".getBytes(); bos.write(bytes); //刷新缓存 bos.flush(); bos.close(); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } ","date":"2019-07-25","objectID":"/java-io/:3:0","tags":["io"],"title":"java IO流","uri":"/java-io/"},{"categories":["JAVA基础"],"content":"BufferedInputStream import java.io.*; public class IoTest { public static void main(String args[]){ try { File file = new File(\"E:\"+File.separator+\"tt.txt\"); InputStream is = new FileInputStream(file); BufferedInputStream bis = new BufferedInputStream(is); byte[] bytes = new byte[(int) file.length()]; bis.read(bytes); System.out.println(new String(bytes)); bis.close(); is.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } 字符流 ","date":"2019-07-25","objectID":"/java-io/:4:0","tags":["io"],"title":"java IO流","uri":"/java-io/"},{"categories":["JAVA基础"],"content":"FileWriter import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.io.Writer; public class IoTest { public static void main(String args[]){ try { File file = new File(\"aa.txt\"); Writer writer = new FileWriter(file); writer.write(\"土豆。。。\\n\"); writer.write(\"地瓜，对不起\"); writer.close(); } catch (IOException e) { e.printStackTrace(); } } } ","date":"2019-07-25","objectID":"/java-io/:5:0","tags":["io"],"title":"java IO流","uri":"/java-io/"},{"categories":["JAVA基础"],"content":"FileReader import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.Reader; public class IoTest { public static void main(String args[]){ try { File file = new File(\"aa.txt\"); Reader reader = new FileReader(file); char[] chars = new char[1024]; reader.read(chars); System.out.println(new String(chars)); reader.close(); } catch (IOException e) { e.printStackTrace(); } } } 转换流(字节流转字符流) ","date":"2019-07-25","objectID":"/java-io/:6:0","tags":["io"],"title":"java IO流","uri":"/java-io/"},{"categories":["JAVA基础"],"content":"OutputStreamWriter import java.io.*; public class IoTest { public static void main(String args[]){ File file = new File(\"aa.txt\"); try { OutputStream out = new FileOutputStream(file); OutputStreamWriter osw = new OutputStreamWriter(out); osw.write(\"这是字节流转成了字符流\"); String encoding = osw.getEncoding(); System.out.println(\"文件的编码：\"+encoding); //文件的编码：UTF8 osw.close(); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } ","date":"2019-07-25","objectID":"/java-io/:7:0","tags":["io"],"title":"java IO流","uri":"/java-io/"},{"categories":["JAVA基础"],"content":"InputStreamReader import java.io.*; public class IoTest { public static void main(String args[]){ try { File file = new File(\"aa.txt\"); InputStream is = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(is,\"utf-8\");//指定编码 char[] chars = new char[1024]; isr.read(chars); System.out.println(chars); System.out.println(\"编码：\"+isr.getEncoding()); isr.close(); isr.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } 字符缓冲流(高效流) ","date":"2019-07-25","objectID":"/java-io/:8:0","tags":["io"],"title":"java IO流","uri":"/java-io/"},{"categories":["JAVA基础"],"content":"BufferedWriter import java.io.*; public class IoTest { public static void main(String args[]){ File file = new File(\"aa.txt\"); try { OutputStream out = new FileOutputStream(file); OutputStreamWriter osw = new OutputStreamWriter(out); BufferedWriter bw = new BufferedWriter(osw); bw.write(\"hello 这是字符缓冲流\"); bw.newLine(); bw.write(\"下一行\"); bw.close(); osw.close(); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } ","date":"2019-07-25","objectID":"/java-io/:9:0","tags":["io"],"title":"java IO流","uri":"/java-io/"},{"categories":["JAVA基础"],"content":"BufferedReader import java.io.*; public class IoTest { public static void main(String args[]){ try { File file = new File(\"aa.txt\"); InputStream is = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(is,\"utf-8\"); BufferedReader br = new BufferedReader(isr); String str; while ((str=br.readLine())!=null){ System.out.println(str); } br.close(); isr.close(); is.close(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (Exception e){ e.printStackTrace(); } } } 字节流与字符流的区别 字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的 字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容 ","date":"2019-07-25","objectID":"/java-io/:10:0","tags":["io"],"title":"java IO流","uri":"/java-io/"},{"categories":["JAVA基础"],"content":" 异常类型 检查性异常 最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略(Throw)。 错误 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 异常类Exception ","date":"2019-07-25","objectID":"/java-exception/:0:0","tags":["Exception"],"title":"java异常","uri":"/java-exception/"},{"categories":["JAVA基础"],"content":"构造方法 public Exception() 构建一个新的异常，以 null作为其详细信息。 public Exception(String message) 使用指定的详细消息构造新的异常。 public Exception(String message, Throwable cause) 构造一个新的异常与指定的详细信息和原因。 public Exception(Throwable cause) 构造一个新的异常与指定原因。 protected Exception(String message, Throwable cause,boolean enableSuppression,boolean writableStackTrace) 构造一个新的异常，其中包含指定的详细消息，启用或禁用抑制功能，启用或禁用可写栈跟踪。 ","date":"2019-07-25","objectID":"/java-exception/:1:0","tags":["Exception"],"title":"java异常","uri":"/java-exception/"},{"categories":["JAVA基础"],"content":"常用方法 public String getMessage() 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 public Throwable getCause() 返回一个Throwable 对象代表异常原因。 public String toString() 使用getMessage()的结果返回类的串级名字。 public void printStackTrace() 打印toString()结果和栈层次到System.err，即错误输出流。 public StackTraceElement [] getStackTrace() 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 public Throwable fillInStackTrace() 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 处理异常 ","date":"2019-07-25","objectID":"/java-exception/:2:0","tags":["Exception"],"title":"java异常","uri":"/java-exception/"},{"categories":["JAVA基础"],"content":"try-catch public class MyException extends Exception{ public static void main(String[] args) { try { int i=1/0; }catch (ArithmeticException e){ e.printStackTrace(); } catch (Exception e){ e.printStackTrace(); System.out.println(\"这是总异常\"); }finally { System.out.println(\"无论有没有异常，都会执行。比如用于关闭数据库的连接\"); } } } ","date":"2019-07-25","objectID":"/java-exception/:3:0","tags":["Exception"],"title":"java异常","uri":"/java-exception/"},{"categories":["JAVA基础"],"content":"throws public class MyException extends Exception{ public static void main(String[] args) { MyException myException = new MyException(); try { myException.show(); } catch (Exception e) { e.printStackTrace(); } } public void show() throws Exception{//抛出去，谁调用谁处理 int i=1/0; } } ","date":"2019-07-25","objectID":"/java-exception/:4:0","tags":["Exception"],"title":"java异常","uri":"/java-exception/"},{"categories":["JAVA基础"],"content":"注意事项 throws在方法名后边 catch 不能独立于 try 存在。 在 try/catch 后面添加 finally 块并非强制性要求的。 try 代码后不能既没 catch 块也没 finally 块。 try, catch, finally 块之间不能添加任何代码。 自定义异常 public class MyException extends Exception{ public static void main(String[] args) { MyException myException = new MyException(); try { System.out.println(myException.devide(4,2)); System.out.println(\"------正常运行一个\"); int devide = myException.devide(1, 0); System.out.println(\"1/0=\"+devide); }catch (MyException e){ System.out.println(\"这是我定义的异常\"); } } public int devide(int a,int b) throws MyException { if (b==0){ throw new MyException(); }else { return a/b; } } } 运行结果 2 ------正常运行一个 这是我定义的异常 参考：https://www.runoob.com/java/java-exceptions.html ","date":"2019-07-25","objectID":"/java-exception/:5:0","tags":["Exception"],"title":"java异常","uri":"/java-exception/"},{"categories":["JAVA基础"],"content":"jdk1.8 import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; /** * Java 语言的Date(日期)，Calendar(日历)，DateFormat(日期格式)组成了Java标准的一个基本但是非常重要的部分。 */ public class StringTest { public static void main(String[] args) throws ParseException { Date currentTime = new Date(); System.out.println(currentTime); //设置时间格式 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(simpleDateFormat.format(currentTime)); SimpleDateFormat year = new SimpleDateFormat(\"yyyy\");//获取年----其它类似 System.out.println(year.format(currentTime)); Date date = simpleDateFormat.parse(\"2019-1-23 12:00:00\");//把字符串转换成日期 System.out.println(simpleDateFormat.format(date)); //计算时间差currentTime-date相差多少天 Long days = (currentTime.getTime()-date.getTime())/(1000*60*60*24);//参数--毫秒 System.out.println(days); System.out.println(\"---------------------------利用Calendar获取时间值比较方便\"); // Calendar转化为Date Calendar cal=Calendar.getInstance(); Date date1=cal.getTime(); // Date转化为Calendar Calendar cal2=Calendar.getInstance(); cal2.setTime(date); //计算某个日期是那一年的第几天 int d = cal2.get(Calendar.DAY_OF_YEAR); System.out.println(d); //一年的第几周等。。 } } ","date":"2019-07-24","objectID":"/java-date-calender/:1:0","tags":["Date","SimpleDateFormat","Calendar"],"title":"Java中Date、SimpleDateFormat、Calendar","uri":"/java-date-calender/"},{"categories":["JAVA基础"],"content":"长度是否可变 String 是被 final 修饰的，他的长度是不可变的，就算调用 String 的concat 方法，那也是把字符串拼接起来并重新创建一个对象，把拼接后的 String 的值赋给新创建的对象 StringBuffer 和 StringBuilder修改本身 ","date":"2019-07-24","objectID":"/string-stringbuffer-stringbuilder/:1:0","tags":["String","StringBuffer","StringBuilder"],"title":"String、StringBuffer、StringBuilder的区别","uri":"/string-stringbuffer-stringbuilder/"},{"categories":["JAVA基础"],"content":"执行效率 三者在执行速度方面的比较：StringBuilder \u003e StringBuffer \u003e String ","date":"2019-07-24","objectID":"/string-stringbuffer-stringbuilder/:2:0","tags":["String","StringBuffer","StringBuilder"],"title":"String、StringBuffer、StringBuilder的区别","uri":"/string-stringbuffer-stringbuilder/"},{"categories":["JAVA基础"],"content":"应用场景 如果要操作少量的数据用 = String 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 多线程操作字符串缓冲区 下操作大量数据 = StringBuffer ","date":"2019-07-24","objectID":"/string-stringbuffer-stringbuilder/:3:0","tags":["String","StringBuffer","StringBuilder"],"title":"String、StringBuffer、StringBuilder的区别","uri":"/string-stringbuffer-stringbuilder/"},{"categories":["JAVA基础"],"content":"线程安全 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问），StringBuffer是线程安全的。只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 ","date":"2019-07-24","objectID":"/string-stringbuffer-stringbuilder/:4:0","tags":["String","StringBuffer","StringBuilder"],"title":"String、StringBuffer、StringBuilder的区别","uri":"/string-stringbuffer-stringbuilder/"},{"categories":["JAVA基础"],"content":"参考 https://www.cnblogs.com/AmyZheng/p/9415064.html ","date":"2019-07-24","objectID":"/string-stringbuffer-stringbuilder/:4:1","tags":["String","StringBuffer","StringBuilder"],"title":"String、StringBuffer、StringBuilder的区别","uri":"/string-stringbuffer-stringbuilder/"},{"categories":["JAVA基础"],"content":"进程和线程概念 进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。进程是线程的容器。 线程(thread)是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务。 同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。 一个进程可以有很多线程，每条线程并行执行不同的任务。 线程 在 Java程序中，有两种方法创建线程： 一继承Thread重写run方法 二是通过实现Runnable接口，实现run方法 线程总体分两类：用户线程和守候线程。 当所有用户线程执行完毕的时候，JVM自动关闭。但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的。 ","date":"2019-07-24","objectID":"/java-thread/:0:0","tags":["thread"],"title":"Java中的线程","uri":"/java-thread/"},{"categories":["JAVA基础"],"content":"继承Thread public class ThreadOne extends Thread{ private String name; public ThreadOne() { } public ThreadOne(String name) { this.name = name; } @Override public void run() { for(int i=1;i\u003c=10;i++){ System.out.println(name+\"----\"+i); } } } public class ThreadTest { public static void main(String[] args) { ThreadOne threadOne1 = new ThreadOne(\"地瓜\"); ThreadOne threadOne2 = new ThreadOne(\"土豆\"); threadOne1.start(); threadOne2.start(); } } ","date":"2019-07-24","objectID":"/java-thread/:1:0","tags":["thread"],"title":"Java中的线程","uri":"/java-thread/"},{"categories":["JAVA基础"],"content":"实现Runnable接口 public class ThreadTwo implements Runnable { private String name; public ThreadTwo() { } public ThreadTwo(String name) { this.name = name; } @Override public void run() { for(int i=1;i\u003c=10;i++){ System.out.println(name+\"-------\"+i); } } } public class ThreadTest { public static void main(String[] args) { Thread t1 = new Thread(new ThreadTwo(\"地瓜\")); Thread t2 = new Thread(new ThreadTwo(\"土豆\")); t1.start(); t2.start(); } } 线程的转换 新建状态：线程对象已经创建 就绪状态：执行了start 运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。 阻塞：线程仍旧是活的，但是当前没有条件运行。 死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 ","date":"2019-07-24","objectID":"/java-thread/:2:0","tags":["thread"],"title":"Java中的线程","uri":"/java-thread/"},{"categories":["Spring Boot"],"content":" 本文环境 jdk 1.8 maven 3.6.1 Spring Boot 2.1.6 SLF4J ","date":"2019-07-20","objectID":"/spring-boot-logback/:0:0","tags":["SLF4J","Spring Boot"],"title":"Spring Boot打印日志","uri":"/spring-boot-logback/"},{"categories":["Spring Boot"],"content":"为什么要介绍SLF4J？ SLF4J是一个接口，log4j和logback是它的实现。 SLF4J官网：https://www.slf4j.org ","date":"2019-07-20","objectID":"/spring-boot-logback/:1:0","tags":["SLF4J","Spring Boot"],"title":"Spring Boot打印日志","uri":"/spring-boot-logback/"},{"categories":["Spring Boot"],"content":"官网示例 引入jar包 slf4j-api-1.7.26.jar slf4j-simple-1.7.26.jar 编写测试类(Java Project) import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); } } 有什么问题，去官网查看示例！ Spring Boot中使用日志(logback) ","date":"2019-07-20","objectID":"/spring-boot-logback/:2:0","tags":["SLF4J","Spring Boot"],"title":"Spring Boot打印日志","uri":"/spring-boot-logback/"},{"categories":["Spring Boot"],"content":"编写测试类 import org.junit.Test; import org.junit.runner.RunWith; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class LogbackTest { //记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void logTest() { //日志的级别 //从上到下---由低到高 //日志会在设置的级别和高级别生效，Spring Boot默认info logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); //可以在logback-spring.xml或者在application.xml配置日志级别 logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\"); } } ","date":"2019-07-20","objectID":"/spring-boot-logback/:3:0","tags":["SLF4J","Spring Boot"],"title":"Spring Boot打印日志","uri":"/spring-boot-logback/"},{"categories":["Spring Boot"],"content":"设置日志的格式 resources/logback-spring.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cconfiguration debug=\"false\" scan=\"true\" scanPeriod=\"60 seconds\"\u003e \u003c!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径 --\u003e \u003c!-- \u003cproperty name=\"LOG_PATH\" value=\"/data/log/process/springboot-demo\" /\u003e --\u003e \u003cspringProperty name=\"LOG_PATH\" source=\"logging.path\" defaultValue=\"../logs\" /\u003e \u003c!-- 控制台输出 --\u003e \u003cappender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003cencoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"\u003e \u003c!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\u003c/pattern\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!-- 按照每天生成日志文件 --\u003e \u003cappender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!--日志文件输出的文件名 --\u003e \u003cFileNamePattern\u003e${LOG_PATH}/log.log.%d{yyyy-MM-dd}\u003c/FileNamePattern\u003e \u003c!--日志文件保留天数 --\u003e \u003c!-- \u003cMaxHistory\u003e30\u003c/MaxHistory\u003e --\u003e \u003c/rollingPolicy\u003e \u003cencoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"\u003e \u003c!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --\u003e \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\u003c/pattern\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!-- 日志输出级别 --\u003e \u003croot level=\"INFO\"\u003e \u003cappender-ref ref=\"FILE\" /\u003e \u003cappender-ref ref=\"STDOUT\" /\u003e \u003c/root\u003e \u003c/configuration\u003e ","date":"2019-07-20","objectID":"/spring-boot-logback/:4:0","tags":["SLF4J","Spring Boot"],"title":"Spring Boot打印日志","uri":"/spring-boot-logback/"},{"categories":["Spring Boot"],"content":"配置文件的加载顺序 application.properties或者application.yml文件作为Spring Boot的默认配置文件 file：.config/ file: ./ classpath: /config/ classpath: / 以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容 可以通过配置spring.config.location来改变默认配置 ","date":"2019-07-20","objectID":"/spring-boot-logback/:5:0","tags":["SLF4J","Spring Boot"],"title":"Spring Boot打印日志","uri":"/spring-boot-logback/"},{"categories":["Spring Boot"],"content":"application基本配置 #log logging.config=classpath:logback-spring.xml logging.path=D:/log ","date":"2019-07-20","objectID":"/spring-boot-logback/:6:0","tags":["SLF4J","Spring Boot"],"title":"Spring Boot打印日志","uri":"/spring-boot-logback/"},{"categories":["Spring Boot"],"content":"官网日志配置详情 https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-logging.html ","date":"2019-07-20","objectID":"/spring-boot-logback/:7:0","tags":["SLF4J","Spring Boot"],"title":"Spring Boot打印日志","uri":"/spring-boot-logback/"},{"categories":["Spring Boot"],"content":" 本文环境 jdk 1.8 maven 3.6.1 Spring Boot 2.1.6 引入依赖 pom.xml \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-mail\u003c/artifactId\u003e \u003c/dependency\u003e 在application.properties中添加邮件配置(以QQ邮箱为例) spring.mail.host=smtp.qq.com spring.mail.port=587 spring.mail.username=xxx@qq.com spring.mail.password=授权码 spring.mail.properties.mail.smtp.auth=true spring.mail.properties.mail.smtp.starttls.enable=true spring.mail.properties.mail.smtp.starttls.required=true spring.mail.default-encoding=UTF-8 mail.fromMail.addr=xxx@qq.com #发送来源，和账户相同 QQ邮箱的服务器端口 接收邮件服务器：imap.qq.com，使用SSL，端口号993 发送邮件服务器：smtp.qq.com，使用SSL，端口号465或587 QQ邮箱帮助中心 编写Service接口 public interface MailService { public void sendSimpleMail(String to,String subject,String content); public void sendHtmlMail(String to, String subject, String content); public void sendAttachmentsMail(String to, String subject, String content, String filePath); } } 编写Service的实现类 import java.io.File; import javax.mail.MessagingException; import javax.mail.internet.MimeMessage; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.io.FileSystemResource; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSender; import org.springframework.mail.javamail.MimeMessageHelper; import org.springframework.stereotype.Component; @Component public class MailServiceImpl implements MailService{ private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private JavaMailSender mailSender; @Value(\"${mail.fromMail.addr}\") private String from; @Override public void sendSimpleMail(String to, String subject, String content) { SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(content); try { mailSender.send(message); logger.info(\"简单邮件已经发送\"); } catch (Exception e) { logger.error(\"发送简单邮件时发生异常!\",e); } } @Override public void sendHtmlMail(String to, String subject, String content) { MimeMessage message = mailSender.createMimeMessage(); try { //true表示需要创建一个multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); mailSender.send(message); logger.info(\"html邮件发送成功\"); } catch (MessagingException e) { logger.error(\"发送html邮件时发生异常！\", e); } } @Override public void sendAttachmentsMail(String to, String subject, String content, String filePath) { MimeMessage message = mailSender.createMimeMessage(); try { MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName, file); mailSender.send(message); logger.info(\"带附件的邮件已经发送。\"); } catch (MessagingException e) { logger.error(\"发送带附件的邮件时发生异常！\", e); } } } 编写测试类 import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import com.boot.service.MailService; @RunWith(SpringRunner.class) @SpringBootTest public class MailTest { @Autowired private MailService mailService; @Test public void testSimple() { mailService.sendSimpleMail(\"xxx@163.com\", \"test simple mail\", \"hello this is simple mail\"); } @Test public void testHtmlMail() throws Exception { String content=\"\u003chtml\u003e\\n\" + \"\u003cbody\u003e\\n\" + \" \u003ch3\u003ehello world ! 这是一封Html邮件!\u003c/h3\u003e\\n\" + \"\u003c/body\u003e\\n\" + \"\u003c/html\u003e\"; mailService.sendHtmlMail(\"xxx@163.com\",\"test simple mail\",content); } @Test public void sendAttachmentsMail() { String filePath=\"D:\\\\testMail.tx","date":"2019-07-19","objectID":"/spring-boot-mail/:0:0","tags":["Spring Boot","Mail"],"title":"Spring Boot发送邮件","uri":"/spring-boot-mail/"},{"categories":["浏览器"],"content":" 区别 request session 描述 一次请求(访问一个url) 一次对话(可以访问多个url) 作用 获取信息(表单,查询,cookie等信息) 记录变量(跟踪记录访问者动作) 作用端 浏览器 服务器 生命周期 提交以后即释放 关闭浏览器或者超出会话时间限制(maxInactiveIntervalInSeconds;The session timeout in seconds. By default, it is set to 1800 seconds (30 minutes).) 占用资源 比较少 相对较大 安全性 比较高 稍微低点 ","date":"2019-07-19","objectID":"/requestandsession/:0:0","tags":["request","session"],"title":"request和Session","uri":"/requestandsession/"},{"categories":["数据库连接池"],"content":"阿里巴巴数据库事业部出品，为监控而生的数据库连接池。 托管于GitHub,项目地址 https://github.com/alibaba/druid Druid是一个JDBC组件库，包括数据库连接池、SQL Parser等组件。DruidDataSource是最好的数据库连接池。 Springboot使用 最新信息去GitHub ","date":"2019-07-18","objectID":"/druid-database-connection-pool/:0:0","tags":["Druid"],"title":"Druid数据库连接池","uri":"/druid-database-connection-pool/"},{"categories":["数据库连接池"],"content":"Maven \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.17\u003c/version\u003e \u003c/dependency\u003e ","date":"2019-07-18","objectID":"/druid-database-connection-pool/:1:0","tags":["Druid"],"title":"Druid数据库连接池","uri":"/druid-database-connection-pool/"},{"categories":["数据库连接池"],"content":"Gradle compile 'com.alibaba:druid-spring-boot-starter:1.1.17' 配置 Github上有说明，下面是一下常用配置 application.properties #mysql spring.datasource.platform=mysql spring.datasource.url=jdbc:mysql://localhost:3306/database?serverTimezone=GMT%2B8\u0026useUnicode=true\u0026characterEncoding=utf8 spring.datasource.username=root spring.datasource.password=154704 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #druid spring.datasource.type=com.alibaba.druid.pool.DruidDataSource # Advanced configuration... spring.datasource.max-active=500 spring.datasource.min-idle=2 spring.datasource.initial-size=6 开启监测 DruidConfiguration 监测地址：http://localhost:8080/druid/index.html import javax.sql.DataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.alibaba.druid.pool.DruidDataSource; import com.alibaba.druid.support.http.StatViewServlet; @Configuration public class DruidConfiguration { @ConfigurationProperties(\"spring.datasource\") @Bean public DataSource druidDataSource() { return new DruidDataSource(); } @Bean public ServletRegistrationBean\u003cStatViewServlet\u003e druidStatViewServlet() { ServletRegistrationBean\u003cStatViewServlet\u003e registrationBean = new ServletRegistrationBean\u003c\u003e(new StatViewServlet(), \"/druid/*\"); registrationBean.addInitParameter(\"allow\", \"127.0.0.1\");// IP白名单 (没有配置或者为空，则允许所有访问) registrationBean.addInitParameter(\"deny\", \"\");// IP黑名单 (存在共同时，deny优先于allow) registrationBean.addInitParameter(\"loginUsername\", \"root\"); registrationBean.addInitParameter(\"loginPassword\", \"123456\"); registrationBean.addInitParameter(\"resetEnable\", \"false\"); return registrationBean; } } 测试类 import java.sql.Connection; import javax.sql.DataSource; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class SpringbootApplicationTests { @Autowired DataSource dataSource; @Test public void contextLoads() { } @Test public void test1() throws Exception { System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection.getClass()); connection.close(); } } ","date":"2019-07-18","objectID":"/druid-database-connection-pool/:2:0","tags":["Druid"],"title":"Druid数据库连接池","uri":"/druid-database-connection-pool/"},{"categories":["JAVA基础"],"content":"特点 是Java中唯一一个没有父类的类 java中所有的类不是object类的直接子类，就是其间接子类 定义在object类中的所有方法，在任何类中都可以直接调用，而不需要声明object类的对象。 是java中所有类的超类（基类 ，父类） object类中只有无参构造 方法 常用方法 public boolean equals（object obj） public boolean equals(Object obj) { return (this == obj); } 指示其他某个对象是否与此对象“相等”。 (ps:==判断是否引用地址相同) 2. public String tostring（) 返回对象的字符串表示形式。 3. public int hashCode() 返回此对象的一个哈希码值。 不常用方法 protected Object clone() 创建并返回此对象的一个副本。 protected void finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 finalize 方法，以配置系统资源或执行其他清除。 public final Class\u003c?\u003e getClass() 返回此 Object 的运行时类。 public final void notify() 唤醒在此对象监视器上等待的单个线程。 public final void notifyAll() 唤醒在此对象监视器上等待的所有线程。 public final void wait() 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。 public final void wait(long timeout) 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。 public final void wait(long timeout,int nanos) 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。 ","date":"2019-07-18","objectID":"/object/:0:0","tags":["Object"],"title":"Object类","uri":"/object/"},{"categories":["数据库"],"content":"事务五个隔离级别 DEFAULT 使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别 . READ_UNCOMMITTED 会出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 ) READ_COMMITTED 会出现不可重复读、幻读问题（锁定正在读取的行） REPEATABLE_READ 会出幻读（锁定所读取的所有行） SERIALIZABLE 保证所有的情况不会发生（锁表） spring中七个事务传播行为 在TransactionDefinition接口中定义了七个事务传播行为。 PROPAGATION_REQUIRED(默认的spring事务传播级别) 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。 PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。 PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。 PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。 PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常 PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行 ","date":"2019-07-18","objectID":"/transaction-spring/:0:0","tags":["transaction"],"title":"数据库隔离级别和传播行为","uri":"/transaction-spring/"},{"categories":["数据库"],"content":"悲观锁和乐观锁：处理的是同一张表的同一行记录 悲观锁 如果使用了(加了一个行锁)，如果事务没有被释放，就会造成其他事务处于等待。 使用数据库提供的锁机制实现悲观锁。 如果数据库不支持设置的锁机制，JPA会使用该数据库提供的合适的锁机制来完成，而不会报错。 使用entityManage.find(class,id,LockModeType);加悲观锁，相当于发送SELECT … FOR UPDATE 使用entityManage.lock(object,LockModeType);加悲观锁，相当于发送SELECT id FROM … FOR UPDATE 乐观锁(性能好) 添加一个私有字段version，不由程序员维护，由JPA自己维护 @Version private long version; ","date":"2019-07-17","objectID":"/pessimistic-lock-and-optimistic-lock/:0:0","tags":["JPA"],"title":"悲观锁和乐观锁","uri":"/pessimistic-lock-and-optimistic-lock/"},{"categories":["思想"],"content":"面向接口编程 要正确地使用Java语言进行面向对象的编程，从而提高程序的复用性，增加程序的可维护性、可扩展性，就必须是面向接口的编程。面向接口的编程就意味着：开发系统时，主体构架使用接口，接口构成系统的骨架。这样就可以通过更换实现接口的类来更换系统的实现。 示例 public interface Person { public void show(); } public class Man implements Person{ @Override public void show() { System.out.println(\"Man...的show方法执行了。。。。\"); } } public class Woman implements Person{ @Override public void show() { System.out.println(\"Woman...中的show方法执行了。。。。\"); } } public class MainTest { public void show(Person person) { person.show(); } public static void main(String[] args) { Person man = new Man();//选择Persion，而不是Man man = new Man(); Person woman = new Woman();//选择Persion，而不是Woman woman = new Woman(); man.show(); woman.show(); System.out.println(\"-----------------\"); MainTest test = new MainTest(); test.show(man); test.show(woman); System.out.println(man instanceof Woman); System.out.println(man instanceof Person); System.out.println(woman instanceof Person); } } 执行结果： Man...的show方法执行了。。。。 Woman...中的show方法执行了。。。。 ----------------- Man...的show方法执行了。。。。 Woman...中的show方法执行了。。。。 false true true 通过更换实现接口的类来更换系统的实现。 ","date":"2019-07-15","objectID":"/interface-oriented-programming/:0:0","tags":["interface"],"title":"什么是面向接口编程","uri":"/interface-oriented-programming/"},{"categories":["聊天软件"],"content":" 首先要感谢deepin,QQ很早就停止linux版的更新了,deepin团队在移植上的力度还是比较大的。以后有机会的话，还会再装deepin的。 也要感谢wszqkzqk，做了整理。 ","date":"2019-04-30","objectID":"/linux-install-qq/:0:0","tags":["linux","QQ"],"title":"linux安装QQ","uri":"/linux-install-qq/"},{"categories":["聊天软件"],"content":"解决方案 GitHub:https://github.com/wszqkzqk/deepin-wine-ubuntu 你也可以看作者的README,但是我没看，作者写的比较精简，有些具体的没看懂怎么操作！！原谅我是个萌新。 第一步：安装deepin-wine环境 上https://github.com/wszqkzqk/deepin-wine-ubuntu页面下载zip包（或用git方式克隆），解压到本地文件夹 在中国推荐用下面的地址，速度更快： (git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git) 在文件夹中打开终端，输入sudo sh ./install.sh一键安装。 第2步，安装相关应用容器 在http://mirrors.aliyun.com/deepin/pool/non-free/d/中下载想要的容器，点击deb安装即可。 （建议在终端下使用dpkg -i安装容器，否则容易误报依赖错误） 第３步，关于托盘 安装TopIconPlus的gnome-shell扩展，命令：sudo apt-get install gnome-shell-extension-top-icons-plus gnome-tweaks，然后用r命令重启gnome-shell(Alt+F2,输入r)，最后用gnome-tweaks开启这个扩展。 ","date":"2019-04-30","objectID":"/linux-install-qq/:1:0","tags":["linux","QQ"],"title":"linux安装QQ","uri":"/linux-install-qq/"},{"categories":["聊天软件"],"content":"参考 https://www.lulinux.com/archives/1319 https://github.com/wszqkzqk/deepin-wine-ubuntu ","date":"2019-04-30","objectID":"/linux-install-qq/:2:0","tags":["linux","QQ"],"title":"linux安装QQ","uri":"/linux-install-qq/"},{"categories":["代理"],"content":"这个插件这是一个工具，常见代理有shadowsocks、Goflyway switchyomega的获取 代码在GitHub上维护:https://github.com/FelisCatus/SwitchyOmega switchyomega的配置 配置auto switch 规则列表地址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 代理设置 参考：https://github.com/Alvin9999/new-pac ","date":"2019-04-28","objectID":"/use-switchyomega/:0:0","tags":["SwitchyOmega"],"title":"使用SwitchyOmega","uri":"/use-switchyomega/"},{"categories":["Linux"],"content":" 注意：推荐参考：https://github.com/zhangxiaofeng05/dotfiles ","date":"2018-08-25","objectID":"/vim-basic-configuration/:0:0","tags":["vim"],"title":"vim基础配置","uri":"/vim-basic-configuration/"},{"categories":["Linux"],"content":"我的配置 系统的vim的配置文件在 /etc/vim/vimrc 当前用户的vim配置文件 ~/.vimrc \" --------------zhangxiaofeng---------------- \" 显示行号 或者 set number set nu \" 语法高亮,自动识别代码,使用多种颜色显示 syntax on \" 不与vi兼容,采用vim自己的操作命令 set nocompatible \" 不支持鼠标,如果想支持把-去掉 set mouse-=a \" 使用utf-8编码 set encoding=utf-8 \" 高亮度搜寻 set hlsearch \" 输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果 set incsearch \" 设置主题 \" colorscheme molokai colorscheme desert \" 高亮显示当前行/列 set cursorline set cursorcolumn \" 修改行/列线的外观 \" highlight CursorLine cterm=NONE ctermbg=black ctermfg=green guibg=NONE guifg=NONE highlight CursorColumn cterm=NONE ctermbg=black ctermfg=green guibg=NONE guifg=NONE \" 按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致 set autoindent \" 按下 Tab 键时，Vim 显示的空格数 set tabstop=4 \" 在文本上按下\u003e\u003e \u003c\u003c等缩进,每一级的字符数 set shiftwidth=4 \" 光标遇到括号,自动高亮对应的括号 set showmatch ","date":"2018-08-25","objectID":"/vim-basic-configuration/:1:0","tags":["vim"],"title":"vim基础配置","uri":"/vim-basic-configuration/"},{"categories":["JAVA基础"],"content":"Linux ","date":"2018-08-23","objectID":"/install-jdk/:0:0","tags":["linux","jdk"],"title":"安装jdk","uri":"/install-jdk/"},{"categories":["JAVA基础"],"content":"下载 官网：https://www.oracle.com/technetwork/java/javase/downloads/index.html ","date":"2018-08-23","objectID":"/install-jdk/:1:0","tags":["linux","jdk"],"title":"安装jdk","uri":"/install-jdk/"},{"categories":["JAVA基础"],"content":"配置环境 解压到/opt sudo tar -zxf jdk-8u211-linux-x64.tar.gz -C /opt/ 修改/etc/profile文件 sudo vi /etc/profile 把下面的添加到文件的末尾 export JAVA_HOME=/opt/jdk1.8.0_211 export JRE_HOME=/opt/jdk1.8.0_211/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 使修改后的文件生效 source /etc/profile Windows ","date":"2018-08-23","objectID":"/install-jdk/:2:0","tags":["linux","jdk"],"title":"安装jdk","uri":"/install-jdk/"},{"categories":["JAVA基础"],"content":"下载 官网：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html ","date":"2018-08-23","objectID":"/install-jdk/:3:0","tags":["linux","jdk"],"title":"安装jdk","uri":"/install-jdk/"},{"categories":["JAVA基础"],"content":"安装 我选择默认安装 C:\\Program Files\\Java\\jdk1.8.0_211 C:\\Program Files\\Java\\jre1.8.0_211 ","date":"2018-08-23","objectID":"/install-jdk/:4:0","tags":["linux","jdk"],"title":"安装jdk","uri":"/install-jdk/"},{"categories":["JAVA基础"],"content":"配置环境 新建系统变量JAVA_HOME 变量名：JAVA_HOME 变量值：C:\\Program Files\\Java\\jdk1.8.0_211 新建系统变量CLASSPATH 变量名：CLASSPATH 变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 在系统变量Path中添加 %JAVA_HOME%\\bin %JAVA_HOME%\\jre\\bin 测试是否成功 java -version java javac ","date":"2018-08-23","objectID":"/install-jdk/:5:0","tags":["linux","jdk"],"title":"安装jdk","uri":"/install-jdk/"},{"categories":["代理"],"content":"安装proxychains 简单粗暴的方式： $ sudo apt-get install proxychains 如果想要使用最新版，也可以自己手动编译源码 # 安装 git clone https://github.com/rofl0r/proxychains-ng.git ./configure --prefix=/usr --sysconfdir=/etc make sudo make install sudo make install-config ","date":"2018-08-16","objectID":"/terminal-use-socks5-proxy/:1:0","tags":["proxy"],"title":"终端使用socks5代理","uri":"/terminal-use-socks5-proxy/"},{"categories":["代理"],"content":"配置 在安装完成之后，一般在 /etc/proxychains.conf 处会有默认配置文件，编辑该文件 sudo vim /etc/proxychains.conf 然后在文件末修改成自己设置的shadowsocks设置的端口，如下 socks5 127.0.0.1 1080 ","date":"2018-08-16","objectID":"/terminal-use-socks5-proxy/:2:0","tags":["proxy"],"title":"终端使用socks5代理","uri":"/terminal-use-socks5-proxy/"},{"categories":["代理"],"content":"验证 $ curl ip.gs 这个显示的ip是没有被代理的 $ proxychains curl ip.gs 这个就是你的代理了 在配置完 proxychains 之后，在终端如果任何命令无法连接成功时，在其前加上 proxychains 就可以走代理方式来执行该命令。 ","date":"2018-08-16","objectID":"/terminal-use-socks5-proxy/:3:0","tags":["proxy"],"title":"终端使用socks5代理","uri":"/terminal-use-socks5-proxy/"},{"categories":["代理"],"content":"shell函数(unix\u0026linux) 如果系统不支持proxychains，可以考虑设置函数。 # .zshrc function proxy_on() { export http_proxy=http://127.0.0.1:1080 export https_proxy=$http_proxy echo -e \"终端代理已开启。\" } function proxy_off(){ unset http_proxy https_proxy echo -e \"终端代理已关闭。\" } ","date":"2018-08-16","objectID":"/terminal-use-socks5-proxy/:4:0","tags":["proxy"],"title":"终端使用socks5代理","uri":"/terminal-use-socks5-proxy/"},{"categories":["代理"],"content":"参考 终端使用 sock5 代理 终端 terminal socks5 shadowsocks 代理 proxy 终端使用代理加速的正确方式(Shadowsocks) ","date":"2018-08-16","objectID":"/terminal-use-socks5-proxy/:5:0","tags":["proxy"],"title":"终端使用socks5代理","uri":"/terminal-use-socks5-proxy/"}]